---
title: "Dashboard - Datos Laborales"
author: "Alejandro Delgado Valera"
output: 
    flexdashboard::flex_dashboard:
        scrolling: true
        vertical_layout: fill
        social: none
runtime: shiny
---

```{r global, include=FALSE}
library(pxR)
library(MASS)
library(shinydashboard)
library(datasets)
library(highcharter) 
library(fpp3)
library(RColorBrewer)
library(openxlsx)  
library(leaflet)  
library(geojsonio)
library(plotly)
library(ggplot2)
library(tidyverse)
pdf(file = NULL) # evita errores en shiny 

# asociamos funciones a determinadas librerías para evitar posibles errores 
filter <- dplyr::filter # Filtra filas según condiciones
select <- dplyr::select # Selecciona columnas
mutate <- dplyr::mutate # Crea o modifica columnas
arrange <- dplyr::arrange # Ordena filas
group_by <- dplyr::group_by # Agrupa datos
summarise <- dplyr::summarise # Resume variables (por ejemplo, con medias, conteos)
summarize <- dplyr::summarize # Lo mismo que summarise
rename <- dplyr::rename # Cambia nombres de columnas
distinct <- dplyr::distinct # Elimina filas duplicadas
slice<- dplyr::slice # Selecciona filas por posición
relocate<- dplyr::relocate # Reordena columnas

selectInput <- shiny::selectInput

# Colocamos las funciones en este mismo fichero para evitar dependencias ####

# Función de Pareto
# Dado un vector de números y un nivel de significancia de Pareto, calcula el valor del vector tal que la suma de los valores por encima de ese valor supera el total de la suma multiplicado por el nivel de significancia.

ParetoValue <- function(
        v, # vector numérico
        ParetoSignificancia # número en [0,1] con el grado de significancia de Pareto
){
    
    x <- sort(v,decreasing = TRUE)
    return(x[which(cumsum(x)>=ParetoSignificancia*sum(x))[1]])
}


#FUNCIÓN PARA DIBUJAR UNA PREDICCIÓN DINÁMICA CON USANDO plotly
GraficoDinamicoArima95CI <- function(
 data, # tssible con con los datos originales
 date, # string con el nombre se la variable temporal en data
 value, # string con el nombre se la variable numérica en data
 prediccion, # objeto con la predicción usando ARIMA u otro modelo
 TITLE # título del gráfico
){

  fc <- prediccion %>%
  mutate(lower = NA) %>%
  mutate(upper = NA)

  for(k in 1:nrow(fc)){
    fc$lower[k] <- fc$.mean[k] - 1.96*unlist(fc[[value]][k])[2]
    fc$upper[k] <- fc$.mean[k] + 1.96*unlist(fc[[value]][k])[2]
  }

  data2 <- data
  x <- data2[[date]][1]
  if(!(is.numeric(x) && !inherits(x, "Date") && !inherits(x, "POSIXt"))){
    data2[[date]] <- as.Date(data2[[date]])
    fc[[date]] <- as.Date(fc[[date]])
  }



p <- plot_ly() %>%
  add_lines(x=data2[[date]], y = data2[[value]], name = "Observación", line = list(color = "black")) %>%
  add_lines(x=fc[[date]], y = fc$.mean, name = "Predicción", line = list(color = "blue")) %>%
  add_ribbons(x = fc[[date]], ymin = fc$lower, ymax = fc$upper,
              name = "95% CI", fillcolor = "rgba(0,0,150,0.2)", line = list(width = 0)) %>%
  layout(
      # Fuente Sans (Arial) y color gris oscuro (#333333)
      font = list(family = "Arial, sans-serif", color = "#333333"),
      
      # Fondo blanco puro
      paper_bgcolor = "#ffffff",
      plot_bgcolor  = "#ffffff",
      
      # Título en negrita
      title = list(
        text = paste0("<b>", TITLE, "</b>"), 
        font = list(size = 25),
        x = 0.5, 
        xanchor = "center",
        yanchor = "top"
      ),
      
      # Eje X: Cuadrícula gris suave (#dee2e6) y sin bordes negros
      xaxis = list(
        title = list(text = "<b>Año</b>", font = list(size = 17)), 
        showgrid = TRUE,
        gridcolor = "#dee2e6", 
        zeroline = FALSE,
        showline = FALSE,
        tickfont = list(color = "#555555"),
        range(100, 200)
      ),
      
      # Eje Y: Igual que el X
      yaxis = list(
        title = list(text = "<b>Valor</b>", font = list(size = 17)),
        showgrid = TRUE,
        gridcolor = "#dee2e6",
        zeroline = FALSE,
        showline = FALSE,
        tickfont = list(color = "#555555")
      ),
      
      # Leyenda arriba (estilo más limpio)
      legend = list(
        font = list(weight = "bold", size=15),
        orientation = "v",   # Vertical
        x = 1.02,            # Justo fuera del gráfico a la derecha
        y = 1,               # Alineada arriba
        xanchor = "left",
        yanchor = "top",
        bgcolor = "rgba(0,0,0,0)"
      ),
      
      # Márgenes ajustados
      margin = list(t = 60, b = 40, l = 20, r = 160)
    )



return(p)
}

#FUNCIÓN PARA DIBUJAR UN MAPA COROPLÉTICO USANDO leaflet
MapaCoroplético <- function(
 geoj, # objeto gráfico geojson con los contornos de las regiones
 value, # vector de valores para colorear 
 region_labels, # vector de etiquetas para los desplegables
 legend_title # título de la leyenda 
){

vals <- value[!is.na(value)]

pal <- colorNumeric(
  palette = "YlOrRd",
  domain  = vals
)

p <-  geoj %>%
    leaflet() %>%  
    setView(lng = 10, lat = 48, zoom = 4)  %>% 
    addPolygons(
        fillColor = ~pal(value),
        weight = 1,
        opacity = 1,
        color = "#555555",
        dashArray = "",
        fillOpacity = 0.75,
        highlightOptions = highlightOptions(
            weight = 3,
            color = "#333333",
            dashArray = "",
            fillOpacity = 0.8,
            bringToFront = TRUE
        ),
      label = region_labels 
    ) %>% 
    addLegend("bottomleft", 
      pal = pal, 
      values = value,
      title = legend_title,
      labFormat = function(type, cuts, p) {
        n = length(cuts) 
        x = (cuts[-n] + cuts[-1])/2
        x=prettyNum(round(x,
            digits=max(5-nchar(as.character(round(max(na.omit(value))))),0)), 
            big.mark = ","
        )
        as.character(x)
      },
 
      opacity = 1
      )
  return(p)
}



# CÁLCULO DE LA TRANSFORMACIÓN DE YEO–JOHNSON A PARTIR DE UN VECTOR Y UN VALOR DE lambda 
yeo.johnson <- function(y, lambda) {
  y_t <- numeric(length(y))
  
  # Para y >= 0
  pos_idx <- which(y >= 0)
  if (lambda == 0) {
    y_t[pos_idx] <- log(y[pos_idx] + 1)
  } else {
    y_t[pos_idx] <- ((y[pos_idx] + 1)^lambda - 1) / lambda
  }
  
  # Para y < 0
  neg_idx <- which(y < 0)
  if (lambda == 2) {
    y_t[neg_idx] <- -log(-y[neg_idx] + 1)
  } else {
    y_t[neg_idx] <- -(((-y[neg_idx] + 1)^(2 - lambda) - 1) / (2 - lambda))
  }
  
  return(y_t)
}


# ESTIMACIÓN DE lambda PARA LA TRANSFORMACIÓN DE YEO–JOHNSON DE UN VECTOR y
# OPTIMIZANDO  EL R2 DE LA REGRESIÓN LINEAL CON UN VECTOR x.  
optimize.yeojohnson.R2 <- function(x, y, lambda_range = c(-1, 1.9)) {
 
  # Función objetivo: R² negativo (porque optimize minimiza)
  r2_neg <- function(lambda) {
    y_t <- yeo.johnson(y, lambda)
    modelo <- lm(y_t ~ x)
    return(-summary(modelo)$r.squared)  # queremos maximizar R²
  }
  
  # Optimización de lambda
  opt <- optimize(r2_neg, interval = lambda_range)
  
  # Se retorna el valor óptimo de lambda 
  return(opt$minimum)
}

```
```{r estilo-graficas, include=FALSE}
# Configuramos el tema sin especificar familia de fuente (usará la estándar)
theme_set(
  theme_minimal() + 
  theme(
    # --- TEXTO GENERAL ---
    # Solo definimos el color gris oscuro para que coincida con tu CSS
    text = element_text(color = "#333333"),
    
    # --- TÍTULOS DE GRÁFICO ---
    plot.title = element_text(face = "bold", size = 16, hjust = 0.5, margin = margin(b = 10)),
    plot.subtitle = element_text(face = "italic", size = 12, hjust = 0.5, color = "#666666"),
    
    # --- EJES ---
    axis.title = element_text(face = "bold", size = 12),
    axis.text = element_text(size = 10, color = "#555555"),
    
    # --- LEYENDA ---
    legend.position = "top",
    legend.title = element_text(face = "bold", size = 11),
    legend.text = element_text(size = 10),
    
    # --- FACETAS (Títulos de las cajitas de países - strip) ---
    # Esto es clave para que tu gráfica de múltiples países se vea bien
    strip.text = element_text(face = "bold", size = 11, color = "#333333"),
    strip.background = element_rect(fill = "#f8f9fa", color = NA), # Fondo gris muy suave para el título
    
    # --- FONDO Y CUADRÍCULA (Coincide con el CSS) ---
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA),
    panel.grid.major = element_line(color = "#dee2e6", size = 0.4), # Gris suave
    panel.grid.minor = element_blank(),
    plot.margin = margin(15, 15, 15, 15)
  )
)

# --- Actualizar textos DENTRO del gráfico (geom_text) ---
# Quitamos cualquier referencia a familias de fuente aquí también
update_geom_defaults("text", list(color = "#333333"))
update_geom_defaults("label", list(color = "#333333"))

```
```{css, echo=FALSE}
/* 1. PALETA DE COLORES NEUTRA */
:root {
  --main-color: #343a40;        /* Gris Oscuro para Header */
  --accent-color: #007bff;      /* Azul Estándar (Sólo para Hover/Activo) */
  --text-color-dark: #333333;   /* Gris Oscuro para Texto Principal y Inputs */
  --light-bg: #f8f9fa;          /* Fondo muy, muy claro */
  --sidebar-bg: #ffffff;        /* Fondo Blanco para Sidebar (limpio) */
  --card-bg: #ffffff;           /* Fondo Blanco para Paneles/Gráficos */
  --border-color: #dee2e6;       /* Gris muy claro para bordes */
  --border-radius-soft: 8px;    /* Radio de Borde Suave */
}

/* 2. ESTILO DEL CUERPO Y FUENTE (Open Sans) */
body {
  font-family: 'Open Sans', sans-serif;
  background-color: var(--light-bg);
  color: var(--text-color-dark);
}

/* 3. SIDEBAR Y TÍTULOS DE INPUTS */
.main-sidebar {
  background-color: var(--sidebar-bg) !important;
  box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.05);
  border-right: 1px solid var(--border-color);
}

/* Asegura que los títulos de los inputs sean oscuros */
.shiny-input-container label, .form-group label {
  color: var(--text-color-dark) !important;
  font-weight: 600;
  padding-bottom: 5px;
}

/* 4. ENCABEZADO SUPERIOR (HEADER) */
.navbar {
  background-color: var(--main-color) !important;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  border-bottom: none;
}

.navbar-brand, .navbar-nav > li > a {
  color: #ffffff !important;
  font-weight: 600;
}

.navbar-nav > li.active > a,
.navbar-nav > li.active > a:hover,
.navbar-nav > li.active > a:focus {
  background-color: #495057 !important;
  border-bottom: 3px solid var(--accent-color);
}

/* 5. CONTROLES/INPUTS (SHINY NATIVOS) - Redondeados, Legibles y Discretos */

/* Aplica a selectInput, numericInput, sliderInput, etc. */
.form-control {
  border-radius: var(--border-radius-soft) !important;
  border: 1px solid var(--border-color);
  box-shadow: none;
  /* Asegura el color de texto para todos los inputs */
  color: var(--text-color-dark) !important; 
  background-color: #ffffff !important; /* Fondo siempre blanco para contraste */
}

/* Estilo para el foco (el resaltado cuando el input está activo) */
.form-control:focus {
  border-color: var(--accent-color) !important;
  box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}


/* Estilo para los botones de las pestañas laterales (e.g., NUTS) */
.btn-default {
  border-radius: var(--border-radius-soft);
  border: 1px solid var(--border-color);
  background-color: #ffffff;
}

.btn-default.active {
  background-color: var(--accent-color);
  color: #ffffff;
  border-color: var(--accent-color);
}

.btn-default:hover {
  background-color: #e9ecef;
}

/* 6. PANELES Y CAJAS (para los gráficos) */
.box {
  background-color: var(--card-bg);
  border-radius: var(--border-radius-soft);
  box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.05); 
  padding: 15px; 
}

/* 7. TÍTULOS DE PANELES */
.flexdashboard .panel-title {
  color: var(--text-color-dark); 
  font-weight: 600;
  border-bottom: 1px solid var(--border-color);
  padding-bottom: 5px;
  margin-bottom: 10px;
}

/* --- ESTILO PARA CAJAS DE MÉTRICAS (RMSE, MODELO) --- */
.box-metricas {
  /* Fondo y borde similar al de los inputs/botones */
  background-color: var(--card-bg); /* Blanco */
  border: 1px solid var(--border-color); /* Borde gris suave */
  border-radius: var(--border-radius-soft); /* Bordes redondeados */
  padding: 10px 15px; /* Espacio interno */
  margin-bottom: 15px; /* Espacio debajo */
  box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.03); /* Sombra muy sutil */
  text-align: left; /* Alineación del texto */
}

/* Estilo para las etiquetas (RMSE, Modelo Seleccionado) */
.box-metricas h4 {
  color: var(--text-color-dark); /* Color de texto oscuro */
  font-family: 'Open Sans', sans-serif;
  font-weight: 600; /* Semi-negrita para destacar */
  font-size: 14px;
  margin-top: 0;
  margin-bottom: 5px; /* Espacio debajo de la etiqueta */
}

/* Estilo para los valores numéricos/modelos */
.box-metricas h2, .box-metricas h3 {
  color: var(--main-color); /* Usa el color principal del header (gris oscuro) para el valor */
  font-family: 'Open Sans', sans-serif;
  font-weight: 300; /* Negrita */
  margin-top: 0;
  font-size: 18px;
  margin-bottom: 0;
  line-height: 1.1; /* Espacio de línea ajustado */
}
```


<!-- Carga inicial de los datos -->
```{r analisis-data-raw, results=F}
data_raw <- read_csv('data/nama_10r_2lp10.csv') %>% 
    as_tibble()

data_raw
```
```{r analisis-inicial, results=F}
real_names <- read_csv('data/eurostac_real_nuts.csv') %>% 
    as_tibble()


data <- data_raw %>% 
    select(-freq) %>% 
    rename(year = TIME_PERIOD, sector = nace_r2, item = na_item) %>% 
    left_join(real_names, by='geo') %>% 
    select(geo, NUTS, full_name, year, sector, item, unit, values) %>% 
    mutate(sector_name = case_when(
        sector == "TOTAL" ~ "Total actividades",
        sector == "O-U" ~ "Adm. pública, educación y salud",
        sector == "O-Q" ~ "Adm. pública, defensa y educación",
        sector == "B-E" ~ "Industria",
        sector == "K-N" ~ "Finanzas e inmobiliarias",
        sector == "F" ~ "Construcción",
        sector == "M_N" ~ "Profesionales y científicas",
        sector == "A" ~ "Agricultura y pesca",
        sector == "C" ~ "Manufactura",
        sector == "G-J" ~ "Comercio y transporte",
        sector == "R-U" ~ "Artes y otros servicios",
        sector == "G-I" ~ "Comercio y alojamiento",
        sector == "J" ~ "Información y comunicación",
        sector == "K" ~ "Finanzas",
        sector == "L" ~ "Inmobiliarias",
        TRUE ~ "Otro"
        )) %>% 
    relocate(sector_name, .after=sector)
    

data
```
```{r archivos-geoj, results=F}
# Carga de datos geográficos locales (mucho más rápido)
geoj0 <- readRDS("data/geoj0.rds")
geoj1 <- readRDS("data/geoj1.rds")
geoj2 <- readRDS("data/geoj2.rds")

geoj0.tb <- geoj0 %>% as_tibble()
geoj1.tb <- geoj1 %>% as_tibble()
geoj2.tb <- geoj2 %>% as_tibble()
```


Series temporales (por países)
=================
```{r ST_paises-analisis-data}
filtrado_series_temporales <- reactive({
    tb <- data %>% 
        filter(item == input$indicador, unit == input$unidad, sector_name == input$sector)
    return(tb)
})
```

```{r ST_paises-widgets-seleccion}
# --- Relación entre indicadores (códigos del dataset) y las unidades disponibles ---
indicador_unidades <- list(
    "D1_SAL_PER" = c("EUR", "NAC", "PC_EU27_2020_MEUR_CP"),
    "D1_SAL_HW"  = c("EUR", "NAC", "PC_EU27_2020_MEUR_CP"),
    "HW_EMP"     = c("HW", "PCH_PRE")
)

# --- Nombres descriptivos para mostrar en el selector ---
indicadores_labels <- c(
    "Coste laboral medio / persona" = "D1_SAL_PER",
    "Coste laboral / hora trabajada" = "D1_SAL_HW",
    "Horas trabajadas en promedio" = "HW_EMP"
)

unidad_labels <- c(
    "EUR" = "EUR",
    "Moneda nacional" = "NAC",
    "Porcentaje UE27" = "PC_EU27_2020_MEUR_CP",
    "Var. porcentual" = "PCH_PRE",
    "Horas anuales" = "HW"
)

# --- Selectores de parámetros ---
div(
    style = "display: flex; align-items: center; gap: 30px;", # Misma línea, separación 30px
  
    # - Indicador -
    div(
        selectInput(
            "indicador",
            label = "Indicador:",
            choices = indicadores_labels,
            selected = "Coste laboral medio / persona"
        )
    ),
  
    # - Unidad -
    div(
        selectInput(
            "unidad",
            label = "Unidad:",
            choices = unidad_labels,
            selected = "EUR"
        )
    ),
  
   # - Sector -
    div(
        selectInput(
            inputId = "sector",
            label = "Sector:",
            choices = c("Total actividades", sort(setdiff(unique(data$sector_name), "Total actividades"))),
            selected = "Total actividades"           
        )
    ),
  
    # Condicional para la comparativa de países
    conditionalPanel(
        # La 'condition' es una expresión de JavaScript.
        condition = "input.ID_DE_TUS_PESTAÑAS == 'Comparativa países'",
    
        div( # Lo envuelvo en un div para que sea un "hijo" del flexbox
            selectInput(
                inputId = "paises_seleccion",
                label = "Selecciona países:",
                choices = data %>% 
                    filter(NUTS==0) %>% 
                    pull(full_name) %>%
                    unique() %>%
                    sort(),
            multiple = TRUE,
            selected = "Spain"
            )
        )
    ),
  
    # Condicional para la comparativa de CCAA
    conditionalPanel(
        # La 'condition' es una expresión de JavaScript.
        condition = "input.ID_DE_TUS_PESTAÑAS == 'Comparativa CCAA'",
    
        div( # Lo envuelvo en un div para que sea un "hijo" del flexbox
            selectInput(
                inputId = "ccaa_seleccion",
                label = "Selecciona comunidades:",
                choices = data %>% 
                    filter((substr(geo, 1, 2) == "ES" & NUTS == 2)) %>% 
                    pull(full_name) %>%
                    unique() %>%
                    sort(),
            multiple = TRUE,
            selected = "Canarias"
            )
        )
    )
)


# --- Para que no se puedan seleccionar unidades que no existen ---
observe({
    req(input$indicador) # Confirmamos que haya algo seleccionado
    
    # obtén el código del indicador seleccionado (por ejemplo "D1_SAL_HW")
    indicador_sel <- input$indicador
    
    # busca las unidades válidas para ese indicador
    unidades_validas <- indicador_unidades[[indicador_sel]]
    
    # filtra tus etiquetas de unidades (para mostrar solo las disponibles)
    unidades_filtradas <- unidad_labels[unidad_labels %in% unidades_validas]
    
    # actualiza el selector de unidad con esas opciones
    updateSelectInput(
        inputId = "unidad",
        choices = unidades_filtradas,
        selected = unidades_filtradas[1]
    )
})

# --- Para que no se puedan seleccionar sectores que no existen ---
observe({
    req(input$indicador, input$unidad) # Confirmamos que haya algo seleccionado
    
    # Filtramos los datos disponibles con los inputs actuales
    sectores_disponibles <- data %>%
        filter(
            item == input$indicador,
            unit == input$unidad
        ) %>%
        pull(sector_name) %>%
        unique() %>%
        sort()

    # Actualizamos las opciones del selector de sector
    updateSelectInput(
        inputId = "sector",
        choices = c("Total actividades", sort(setdiff(unique(sectores_disponibles), "Total actividades"))),
        selected = "Total actividades"
      )
})
```


Column {.tabset}
--------------------------------------------------
```{r ST_paises-agrupaciones-paises}
# España y Canarias
referencia <- c("ES", "ES7")

paises_principales <- c(
  referencia,
  "DE", # Alemania
  "FR", # Francia
  "IT", # Italia
  "NL", # Países Bajos
  "BE", # Bélgica
  "SE", # Suecia
  "PL", # Polonia
  "AT", # Austria
  "DK", # Dinamarca
  "IE", # Irlanda
  "PT", # Portugal
  "CZ", # Chequia
  "HU", # Hungría
  "LU"  # Luxemburgo
)

paises_resto <- c(
  referencia,
  "BG", # Bulgaria
  "HR", # Croacia
  "CY", # Chipre
  "EE", # Estonia
  "EL", # Grecia
  "LT", # Lituania
  "LV", # Letonia
  "FI", # Finlandia
  "MT", # Malta
  "SI", # Eslovenia
  "RO", # Rumanía
  "SK", # Eslovaquia
  "RS", # Serbia
  "MK"  # Macedonia del Norte
)
```

### Países 1
```{r ST_paises-paises1}
# Países 1
renderPlotly({
  tb <- filtrado_series_temporales()
    
  tb %>% 
    filter(geo %in% paises_principales) %>%
    mutate(full_name = factor(full_name,  # Poner Canarias y España primero
                       levels = c("Canarias", "Spain",
                                  setdiff(unique(full_name), c("Canarias", "Spain"))))) %>%
    ggplot(aes(year,y=values)) +
    geom_line() +
    facet_wrap(~full_name,scales = "free_y",ncol=4) +
    theme(axis.text.x = element_text(angle = 45,hjust=1)) + 
    labs(x="",y="")
})
```

### Países 2
```{r ST_paises-paises2}
# Países 2
renderPlotly({
  tb <- filtrado_series_temporales()
    
  tb %>% 
    filter(geo %in% paises_resto) %>%
    mutate(full_name = factor(full_name,  # Poner Canarias y España primero
                       levels = c("Canarias", "Spain",
                                  setdiff(unique(full_name), c("Canarias", "Spain"))))) %>%
    ggplot(aes(year,y=values)) +
    geom_line()+
    facet_wrap(~full_name,scales = "free_y",ncol=4) +
    theme(axis.text.x = element_text(angle = 45,hjust=1)) + 
    labs(x="",y="")
})
```

### CCAA
```{r ST_paises-ccaa}
renderPlotly({
  tb <- filtrado_series_temporales()
    
  tb %>% 
    filter((substr(geo, 1, 2) == "ES" & NUTS == 2) | geo == "ES") %>%
    mutate(full_name = factor(full_name, # Poner Canarias y España primero
                       levels = c("Canarias", "Spain",
                                  setdiff(unique(full_name), c("Canarias", "Spain"))))) %>%
    ggplot(aes(year, y = values)) +
    geom_line() +
    facet_wrap(~full_name, scales = "free_y", ncol = 4) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(x = "", y = "")
})
```

### Comparativa países
```{r ST_paises-input-comparativa-paises}
selectInput(
    inputId = "paises_seleccion",
    label = "Selecciona países:",
    choices = data %>% 
        filter(NUTS==0) %>% 
        pull(full_name) %>%
        unique() %>%
        sort(),
    multiple = TRUE,
    selected = "Spain",
)
```

```{r ST_paises-comparativa-paises}
div(renderHighchart({
      req(input$paises_seleccion, input$indicador, input$unidad) # Validar que los inputs no estén vacíos
      
    # 1. Datos de las CCAA (del input)
      data_paises <- filtrado_series_temporales() %>%
        filter(
          full_name %in% input$paises_seleccion,
          item == input$indicador,
          unit == input$unidad
        ) %>%
        arrange(year)
        
      # 2. Datos de EU27 (siempre)
      data_eu <- filtrado_series_temporales() %>%
        filter(
          geo == "EU27_2020", 
          item == input$indicador,
          unit == input$unidad
        ) %>%
        arrange(year)
    
      # 3. Gráfico base (con CCAA) y añadir serie de España
      hchart(
        data_paises, # Gráfico base con las CCAA seleccionadas
        type = "line",
        hcaes(x = year, y = values, group = full_name),
        marker = list(enabled = TRUE)
      ) %>%
      
        hc_add_series(
          data = data_eu,          
          type = "line",
          hcaes(x = year, y = values),
          name = "Media UE (Referencia)",
          dashStyle = "Dash",   
          color = "lightgrey",  
          marker = list(enabled = FALSE) 
        ) %>%
        hc_title(text = "") %>%
        hc_xAxis(title = list(text = NULL)) %>%
        hc_yAxis(title = list(text = NULL)) %>%
        hc_legend(enabled = TRUE) %>% 
        hc_chart(height = 500)
    })
)

```

### Comparativa CCAA
```{r ST_paises-input-comparativa-ccaa}
# Selector de comunidades
selectInput(
    inputId = "ccaa_seleccion",
    label = "Selecciona comunidades:",
    choices = data %>% 
        filter((substr(geo, 1, 2) == "ES" & NUTS == 2)) %>% 
        pull(full_name) %>%
        unique() %>%
        sort(),
    multiple = TRUE,
    selected = "Canarias",
)
```

```{r ST_paises-comparativa-ccaa}
div(renderHighchart({
      req(input$ccaa_seleccion, input$indicador, input$unidad) # Validar que los inputs no estén vacíos
      
    # 1. Datos de las CCAA (del input)
      data_ccaa <- filtrado_series_temporales() %>%
        filter(
          full_name %in% input$ccaa_seleccion, # Asumimos que "Spain" no viene aquí
          item == input$indicador,
          unit == input$unidad
        ) %>%
        arrange(year)
        
      # 2. Datos de España (siempre)
      data_espana <- filtrado_series_temporales() %>%
        filter(
          full_name == "Spain", 
          item == input$indicador,
          unit == input$unidad
        ) %>%
        arrange(year)
    
      # 3. Gráfico base (con CCAA) y añadir serie de España
      hchart(
        data_ccaa, # Gráfico base con las CCAA seleccionadas
        type = "line",
        hcaes(x = year, y = values, group = full_name),
        marker = list(enabled = TRUE)
      ) %>%
      
        hc_add_series(
          data = data_espana,          
          type = "line",
          hcaes(x = year, y = values),
          name = "España (Referencia)",
          dashStyle = "Dash",   
          color = "lightgrey",  
          marker = list(enabled = FALSE) 
        ) %>%
        hc_title(text = "") %>%
        hc_xAxis(title = list(text = NULL)) %>%
        hc_yAxis(title = list(text = NULL)) %>%
        hc_legend(enabled = TRUE) %>% 
        hc_chart(height = 500)
    })
)
```


Mapa coroplético
================

Column {.sidebar data-width=285}
--------------------------------------------------

```{r widgets-mapa}
# Widgets para selección de parámetros 
selectInput(
    "indicador_mapa",
    label = "Indicador:",
    choices = indicadores_labels,
    selected = "Coste laboral medio / persona"
)

selectInput(
    "unidad_mapa",
    label = "Unidad:",
    choices = unidad_labels,
    selected = "EUR"
)

selectInput(
    "sector_mapa",
    label = "Sector:",
    choices = c("Total actividades", sort(setdiff(unique(data$sector_name), "Total actividades"))), # Total primero
    selected = "Total actividades"           
)

selectInput(
    "year_mapa", 
    label = "Año:",
    choices = sort(unique(data$year), decreasing = TRUE) , 
    selected = 2023
)

radioButtons(
  inputId = "nuts_mapa",
  label = "NUTS:",
  choices = 0:2,
  selected = 0,
  inline = TRUE
  
)

opciones_mapa <- data %>%
    filter(NUTS == 0) %>%
    select(full_name, geo) %>% 
    distinct() %>%
    arrange(full_name) %>%
    tibble::deframe()

selectInput(
    inputId = "seleccion_mapa",
    label = "Selecciona país(es):",
    choices = opciones_mapa,
    selected = NULL,      # <-- Perfecto, empieza vacío
    multiple = TRUE,      # <-- La clave 1: permite selección múltiple
)


# --- Para que no se puedan seleccionar unidades que no existen ---
observe({
    req(input$indicador_mapa) # Confirmamos que haya algo seleccionado
    
    # obtén el código del indicador seleccionado (por ejemplo "D1_SAL_HW")
    indicador_sel <- input$indicador_mapa
    
    # busca las unidades válidas para ese indicador
    unidades_validas <- indicador_unidades[[indicador_sel]]
    
    # filtra tus etiquetas de unidades (para mostrar solo las disponibles)
    unidades_filtradas <- unidad_labels[unidad_labels %in% unidades_validas]
    
    # actualiza el selector de unidad con esas opciones
    updateSelectInput(
        inputId = "unidad_mapa",
        choices = unidades_filtradas,
        selected = unidades_filtradas[1]
    )
})

# --- Para que no se puedan seleccionar sectores que no existen ---
observe({
    req(input$indicador_mapa, input$unidad_mapa) # Confirmamos que haya algo seleccionado
    
    # Filtramos los datos disponibles con los inputs actuales
    sectores_disponibles <- data %>%
        filter(
            item == input$indicador_mapa,
            unit == input$unidad_mapa
        ) %>%
        pull(sector_name) %>%
        unique() %>%
        sort()

    # Actualizamos las opciones del selector de sector
    updateSelectInput(
        inputId = "sector_mapa",
        choices = c("Total actividades", sort(setdiff(unique(sectores_disponibles), "Total actividades"))),
        selected = "Total actividades"
      )
})

observe({
  # 1. Esperamos a tener todos los inputs necesarios
  req(
    input$indicador_mapa,
    input$unidad_mapa,
    input$sector_mapa,
    input$year_mapa
  )
  
  # 2. Filtramos 'data' para encontrar qué países (NUTS 0)
  #    tienen observaciones (values) NO nulas
  #    para la combinación de filtros actual.
  
  paises_con_datos <- data %>%
    filter(
      item == input$indicador_mapa,
      unit == input$unidad_mapa,
      sector_name == input$sector_mapa,
      year == input$year_mapa,
      NUTS == 0,           # Filtramos solo por países
      !is.na(values)       # ¡La clave! Solo los que tienen datos
    ) %>%
    select(full_name, geo) %>% # Seleccionamos el nombre y el ID
    distinct() %>%
    arrange(full_name)
  
  # 3. Creamos el vector nombrado ("Nombre" = "ID")
  opciones_disponibles <- tibble::deframe(paises_con_datos)
  
  # 4. (Opcional pero recomendado) Mantenemos la selección actual
  #    si los países seleccionados siguen estando en la nueva lista.
  
  # Guardamos la selección actual
  seleccion_actual <- isolate(input$seleccion_mapa)
  
  # Vemos cuáles de los seleccionados siguen siendo válidos
  # Usamos 'opciones_disponibles' (el vector nombrado) para 
  # comprobar contra los 'valores' (los códigos "geo")
  nueva_seleccion <- intersect(seleccion_actual, opciones_disponibles)
  
  # Si la intersección da un vector vacío, lo ponemos como NULL
  # para que el selectInput muestre "Ningún país seleccionado"
  if (length(nueva_seleccion) == 0) {
    nueva_seleccion <- NULL
  }

  # 5. Actualizamos el selectInput
  updateSelectInput(
    inputId = "seleccion_mapa",
    choices = opciones_disponibles,
    selected = nueva_seleccion # Usamos la selección preservada
  )
  
})
```

<!-- Funciones reactive (NO MUESTRA NADA) --> 

```{r funciones-mapa}
inputs.processing.mapa0 <- reactive({
    etiqueta_valida <- paste(
        names(indicadores_labels)[match(input$indicador_mapa, indicadores_labels)], 
        "-",
        names(unidad_labels)[match(input$unidad_mapa, unidad_labels)]
    )
    
  tb <- geoj0.tb %>% 
    left_join(
      data %>%
        filter(year==input$year_mapa, item==input$indicador_mapa, unit==input$unidad_mapa, sector_name==input$sector_mapa, NUTS=="0", is.null(input$seleccion_mapa) | (geo %in% input$seleccion_mapa)),
      join_by("NUTS_ID"=="geo")
    ) %>% 
    mutate(full_name = coalesce(full_name, NAME_LATN),
           # crear etiqueta legible combinando indicador y unidad
            indicador_unidad = etiqueta_valida
    )
  
  return(tb)
})
inputs.processing.mapa1 <- reactive({
    etiqueta_valida <- paste(
        names(indicadores_labels)[match(input$indicador_mapa, indicadores_labels)], 
        "-",
        names(unidad_labels)[match(input$unidad_mapa, unidad_labels)]
    )
        
  tb <- geoj1.tb %>% 
    left_join(
      data %>%
        filter(year==input$year_mapa, item==input$indicador_mapa, unit==input$unidad_mapa, sector_name==input$sector_mapa, NUTS=="1",is.null(input$seleccion_mapa) | (substr(geo, 1, 2) %in% input$seleccion_mapa)),
      join_by("NUTS_ID"=="geo")
    ) %>% 
    mutate(full_name = coalesce(full_name, NAME_LATN),
           # crear etiqueta legible combinando indicador y unidad
            indicador_unidad = etiqueta_valida
    )
  return(tb)
})

inputs.processing.mapa2 <- reactive({
    etiqueta_valida <- paste(
        names(indicadores_labels)[match(input$indicador_mapa, indicadores_labels)], 
        "-",
        names(unidad_labels)[match(input$unidad_mapa, unidad_labels)]
    )
    tb <- geoj2.tb %>% 
        left_join(
        data %>%
        filter(year==input$year_mapa, item==input$indicador_mapa, unit==input$unidad_mapa, sector_name==input$sector_mapa, NUTS=="2", is.null(input$seleccion_mapa) | (substr(geo, 1, 2) %in% input$seleccion_mapa)),
      join_by("NUTS_ID"=="geo")
    ) %>% 
    mutate(full_name = coalesce(full_name, NAME_LATN),
           # crear etiqueta legible combinando indicador y unidad
            indicador_unidad = etiqueta_valida
    )
  
  return(tb)
})
```

### 

<!--Tabla-->
```{r tabla-mapa}
# imprimimos la tabla con el atributo seleccionado 
renderTable({
  tb <- switch (input$nuts_mapa,
      "0" =  inputs.processing.mapa0(),
      "1" =  inputs.processing.mapa1(),
      "2" =  inputs.processing.mapa2()
  )
  
 tb %>% 
    arrange(desc(values))%>%  
    select(full_name,values) %>% 
    filter(!is.na(values)) %>% 
    mutate(Valor=prettyNum(round(values,
    digits=max(5-nchar(as.character(round(max(na.omit(values))))),0)),
    big.mark = ",")) %>% 
    select(Región = full_name, Valor)
 
})
```


Column {.tabset}
--------------------------------------------------

### Mapa coroplético

```{r renderizado-mapa}
# dibujamos el mapa coroplético
leaflet::renderLeaflet({
    # capturamos el resultado del procesado de los inputs 
    res <- switch(
        as.character(input$nuts_mapa),
        
        "0" = list(
            tb   = inputs.processing.mapa0(),
            geoj = geoj0
        ),
        "1" = list(
            tb   = inputs.processing.mapa1(),
            geoj = geoj1
        ),
        "2" = list(
            tb   = inputs.processing.mapa2(),
            geoj = geoj2
        )
    )

tb   <- res$tb
geoj <- res$geoj

etiquetas <-paste(
    "<strong> ",tb$full_name ,
    "</strong><br>",tb$indicador_unidad,
    ": ",prettyNum(round(tb$values,digits=2), big.mark = ",", scientific = FALSE)
  )  %>%
 lapply(htmltools::HTML)

 # dibujamos el mapa 
 MapaCoroplético(geoj,tb$values,etiquetas,"Valor")
 
})
```

Comparación atributos
=====================

Predicción ARIMA
================
Column {.sidebar data-width=275}
--------------------------------------------------
```{r funcion-reactive-arima}
# --- CÁLCULO COMPARTIDO DEL MODELO ARIMA ---
calculo_modelo_arima <- reactive({
  
  # 1. Validamos inputs
  req(
    input$indicador_arima, input$unidad_arima, input$sector_arima,
    input$region_arima, input$year_arima
  )
  
  # 2. Preparamos los datos
  df_raw <- data %>%
    filter(
      item == input$indicador_arima,
      unit == input$unidad_arima,
      sector_name == input$sector_arima,
      geo == input$region_arima
    ) %>%
    select(year, values) %>%
    filter(!is.na(values))

  if (nrow(df_raw) == 0) {
    return(NULL) # Devuelve NULL si no hay datos válidos, para evitar el error momentaneo
  }
  
  # 3. Conversión a tsibble (Serie completa)
  ts_completa <- df_raw %>%
    distinct(year, .keep_all = TRUE) %>% 
    as_tsibble(index = year) %>%
    fill_gaps() 
  
  # 4. Filtro por año de inicio
  year_start <- input$year_arima
  if (length(year_start) == 0) return(NULL)
  
  datos_modelo <- ts_completa %>%
    filter(year >= year_start[1]) %>%
    filter(!is.na(values))
  
  if (nrow(datos_modelo) == 0) {
    return(NULL) # Devuelve NULL si después de filtrar por año no hay datos
  }
  
  # 5. Entrenamos el modelo
  arima_model <- datos_modelo %>%
    model(ARIMA(values)) 
  
  # --- DEVOLVEMOS UNA LISTA CON TODO LO NECESARIO ---
  return(list(
    modelo = arima_model,      # El objeto modelo entrenado
    datos_usados = datos_modelo, # Los datos recortados usados para el modelo
    serie_completa = ts_completa # La serie histórica completa (para pintar el contexto)
  ))
})
```

```{r widgets-arima}
# --- Selectores de parámetros ---
selectInput(
    "indicador_arima",
    label = "Indicador:",
    choices = indicadores_labels,
    selected = "Coste laboral medio / persona"
)

selectInput(
    "unidad_arima",
    label = "Unidad:",
    choices = unidad_labels,
    selected = "EUR"
)

selectInput(
    "sector_arima",
    label = "Sector:",
    choices = c("Total actividades", sort(setdiff(unique(data$sector_name), "Total actividades"))), # Total primero
    selected = "Total actividades"           
)


radioButtons(
  inputId = "nuts_arima",
  label = "NUTS:",
  choices = 0:2,
  selected = 0,
  inline = TRUE
)

selectInput(
    inputId = "region_arima",
    label = "Selecciona país:",
    choices = data %>% 
        filter(NUTS==0) %>% 
        pull(full_name) %>%
        unique() %>%
        sort(),
    selected = "Spain",
    
)

sliderInput(
    inputId = "year_arima",
    label = "Año de inicio datos:",
    min = 2000, # Valor temporal
    max = 2023, # Valor temporal
    value = 2000,
    step = 1,
    sep = "",
    ticks = FALSE
)

radioButtons(
   inputId = "h_arima", # 'h' es la letra típica para el horizonte de predicción
   label = "Años a predecir:",
   choices = 1:5,
   selected = 5, # Por defecto 5 años
   inline = TRUE
)

# --- Para que no se puedan seleccionar unidades que no existen ---
observe({
    req(input$indicador_arima) # Confirmamos que haya algo seleccionado
    
    # obtén el código del indicador seleccionado (por ejemplo "D1_SAL_HW")
    indicador_sel <- input$indicador_arima
    
    # busca las unidades válidas para ese indicador
    unidades_validas <- indicador_unidades[[indicador_sel]]
    
    # filtra tus etiquetas de unidades (para mostrar solo las disponibles)
    unidades_filtradas <- unidad_labels[unidad_labels %in% unidades_validas]
    
    # actualiza el selector de unidad con esas opciones
    updateSelectInput(
        inputId = "unidad_arima",
        choices = unidades_filtradas,
        selected = unidades_filtradas[1]
    )
})

# --- Para que no se puedan seleccionar sectores que no existen ---
observe({
    req(input$indicador_arima, input$unidad_arima) # Confirmamos que haya algo seleccionado
    
    # Filtramos los datos disponibles con los inputs actuales
    sectores_disponibles <- data %>%
        filter(
            item == input$indicador_arima,
            unit == input$unidad_arima
        ) %>%
        pull(sector_name) %>%
        unique() %>%
        sort()

    # Actualizamos las opciones del selector de sector
    updateSelectInput(
        inputId = "sector_arima",
        choices = c("Total actividades", sort(setdiff(unique(sectores_disponibles), "Total actividades"))),
        selected = "Total actividades"
      )
})

# --- Para seleccionar solo regiones disponibles ---
observe({
  # 1. Esperamos a que todos los filtros estén listos
  req(
    input$indicador_arima, 
    input$unidad_arima, 
    input$sector_arima, 
    input$nuts_arima
  )

  # 2. Definimos a quién queremos priorizar según el NUTS
  #    (Asegúrate de que el texto coincida con cómo viene en tus datos: "Spain" o "España")
  prioridad <- if (input$nuts_arima == "0") "Spain" else "Canarias"

  # 3. Filtramos y ORDENAMOS con la nueva lógica
  regiones_disponibles <- data %>%
    filter(
      item == input$indicador_arima,
      unit == input$unidad_arima,
      sector_name == input$sector_arima,
      NUTS == input$nuts_arima, 
      !is.na(values)
    ) %>%
    select(full_name, geo) %>%
    distinct() %>%
    # --- AQUÍ ESTÁ EL TRUCO ---
    # Creamos una columna temporal (TRUE si es el prioritario, FALSE si no)
    mutate(es_prioritario = grepl(prioridad, full_name, ignore.case = TRUE)) %>%
    # Ordenamos: Primero los TRUE (desc), luego alfabéticamente por nombre
    arrange(desc(es_prioritario), full_name) %>%
    # --------------------------
    select(full_name, geo) # Nos quedamos solo con lo que necesitamos
  
  # 4. Convertimos a vector nombrado
  choices_vector <- tibble::deframe(regiones_disponibles)
  
  # 5. Lógica de selección (se mantiene igual)
  seleccion_actual <- isolate(input$paises_arima)
  
  if (!is.null(seleccion_actual) && seleccion_actual %in% choices_vector) {
    nueva_seleccion <- seleccion_actual 
  } else {
    # Como hemos ordenado "Spain"/"Canarias" al principio, 
    # choices_vector[1] seleccionará automáticamente tu prioridad 
    # si la selección anterior no es válida.
    if (length(choices_vector) > 0) {
      nueva_seleccion <- choices_vector[1] 
    } else {
      nueva_seleccion <- NULL
    }
  }
  
  label_texto <- if (input$nuts_arima == "0") "Selecciona país:" else "Selecciona región:"

  # 6. Actualizamos
  updateSelectInput(
    session = session,
    inputId = "region_arima",
    label = label_texto,
    choices = choices_vector,
    selected = nueva_seleccion
  )
})

# --- Para actualizar el año inicial con los años disponibles ---
observe({
  # 1. Esperamos a tener el país/región seleccionado (y el resto de filtros)
  req(
    input$indicador_arima,
    input$unidad_arima,
    input$sector_arima,
    input$region_arima
  )

  # 2. Obtenemos los años disponibles para esa combinación exacta
  años_disponibles <- data %>%
    filter(
      item == input$indicador_arima,
      unit == input$unidad_arima,
      sector_name == input$sector_arima,
      # Aquí usamos el ID (geo) que devuelve el selectInput
      geo == input$region_arima, 
      !is.na(values)
    ) %>%
    pull(year) %>%
    unique()

  # 3. Calculamos min y max (con seguridad por si no hay datos)
  if (length(años_disponibles) > 0) {
    min_year <- min(años_disponibles)
    max_year <- max(años_disponibles)
  } else {
    # Valores por defecto de seguridad si falla la data
    min_year <- 2000 
    max_year <- 2023
  }

  # 4. Actualizamos el slider
  #    Importante: Actualizamos el 'range' (topes) y el 'value' (selección)
  updateSliderInput(
    session = session,
    inputId = "year_arima",
    min = min_year,
    max = max_year,
    value = min_year               # Reseteamos al inicio de los datos
  )
  
})
```

```{r metricas-arima}
# --- MÉTRICAS DEL MODELO (SIDEBAR) ---
renderUI({

# 1. Traemos el modelo
req(calculo_modelo_arima())
  resultado <- calculo_modelo_arima()
  req(resultado)
  
  # 2. Calculamos RMSE
  datos_con_residuos <- augment(resultado$modelo)
  rmse_val <- sqrt(mean(datos_con_residuos$.resid^2, na.rm = TRUE))
  
  # 3. Extraemos el nombre del modelo (ej: ARIMA(0,1,0))
  #    Cogemos la última columna del objeto mable que contiene el modelo
  columna_modelo <- length(resultado$modelo)
  nombre_modelo <- format(resultado$modelo[[columna_modelo]])
  
  # 4. Renderizamos (Estructura limpia)
  tagList(
    
    # Caja RMSE
    div(class = "box-metricas",
        h4("RMSE"),
        h2(prettyNum(round(rmse_val, 2), big.mark = ","))
    ),
    
    # Caja Modelo
    div(class = "box-metricas",
        h4("Modelo Seleccionado"),
        h3(nombre_modelo)
    )
  )      

})
```


<!-- Columna para las gráficas --> 

Column 
--------------------------------------------------

### 

```{r predicion-arima} 
renderPlotly({
  req(calculo_modelo_arima())
      # 1. Llamamos al reactive compartido
      #    Esto valida inputs y calcula el modelo (o recupera el cálculo si ya está hecho)
      resultado <- calculo_modelo_arima()
      
      # 2. Calculamos la predicción (Esto es rápido)
      req(input$h_arima)
      h_val <- as.numeric(input$h_arima)
      
      forecast_pred <- resultado$modelo %>%
        forecast(h = h_val)
      
      nombre_pais <- data %>%
      filter(geo == input$region_arima) %>%
      pull(full_name) %>% 
      unique() %>%
      head(1)
      
      # 3. Graficamos
      #    Usamos 'resultado$serie_completa' para que el gráfico muestre toda la historia
      GraficoDinamicoArima95CI(
        resultado$serie_completa,   
        "year",              
        "values",            
        forecast_pred,       
        paste("Predicción ARIMA -", nombre_pais)
      )
})
```

### 

```{r comparacion-arima} 
renderPlotly({
  req(calculo_modelo_arima())
    # 1. Llamamos al mismo reactive compartido
    resultado <- calculo_modelo_arima()
    
    # 2. Extraemos los valores ajustados (.fitted)
    datos_ajustados <- augment(resultado$modelo)
    
    nombre_pais <- data %>%
      filter(geo == input$region_arima) %>%
      pull(full_name) %>% 
      unique() %>%
      head(1)
    
    # 3. Graficamos con ggplot
    p <- ggplot(datos_ajustados, aes(x = year)) +
    geom_line(aes(y = values, color = "Real"), size = 0.8) +
    geom_line(aes(y = .fitted, color = "Ajuste ARIMA"), linetype = "dashed", size = 0.8) +
    labs(
      title = paste("           Ajuste del modelo -", nombre_pais),
      y = "Valor", x = "Año", color = NULL
    ) +
    scale_color_manual(values = c("Real" = "black", "Ajuste ARIMA" = "#d9534f"))
    p
})
```
