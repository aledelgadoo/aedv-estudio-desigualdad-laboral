---
title: "Dashboard - Datos Laborales"
author: "Alejandro Delgado Valera"
output: 
    flexdashboard::flex_dashboard:
        scrolling: true
        vertical_layout: fill
        social: none
runtime: shiny
---

```{r global, include=FALSE}
library(pxR)
library(MASS)
library(shinydashboard)
library(datasets)
library(highcharter) 
library(fpp3)
library(RColorBrewer)
library(openxlsx)  
library(leaflet)  
library(geojsonio)
library(plotly)
library(ggplot2)
library(tidyverse)
pdf(file = NULL) # evita errores en shiny 

# asociamos funciones a determinadas librerías para evitar posibles errores 
filter <- dplyr::filter # Filtra filas según condiciones
select <- dplyr::select # Selecciona columnas
mutate <- dplyr::mutate # Crea o modifica columnas
arrange <- dplyr::arrange # Ordena filas
group_by <- dplyr::group_by # Agrupa datos
summarise <- dplyr::summarise # Resume variables (por ejemplo, con medias, conteos)
summarize <- dplyr::summarize # Lo mismo que summarise
rename <- dplyr::rename # Cambia nombres de columnas
distinct <- dplyr::distinct # Elimina filas duplicadas
slice<- dplyr::slice # Selecciona filas por posición
relocate<- dplyr::relocate # Reordena columnas

selectInput <- shiny::selectInput

# Colocamos las funciones en este mismo fichero para evitar dependencias ####

# Función de Pareto
# Dado un vector de números y un nivel de significancia de Pareto, calcula el valor del vector tal que la suma de los valores por encima de ese valor supera el total de la suma multiplicado por el nivel de significancia.

ParetoValue <- function(
        v, # vector numérico
        ParetoSignificancia # número en [0,1] con el grado de significancia de Pareto
){
    
    x <- sort(v,decreasing = TRUE)
    return(x[which(cumsum(x)>=ParetoSignificancia*sum(x))[1]])
}


#FUNCIÓN PARA DIBUJAR UNA PREDICCIÓN DINÁMICA CON USANDO plotly
GraficoDinamicoArima95CI <- function(
 data, # tssible con con los datos originales
 date, # string con el nombre se la variable temporal en data
 value, # string con el nombre se la variable numérica en data
 prediccion, # objeto con la predicción usando ARIMA u otro modelo
 TITLE # título del gráfico
){

  fc <- prediccion %>%
  mutate(lower = NA) %>%
  mutate(upper = NA)

  for(k in 1:nrow(fc)){
    fc$lower[k] <- fc$.mean[k] - 1.96*unlist(fc[[value]][k])[2]
    fc$upper[k] <- fc$.mean[k] + 1.96*unlist(fc[[value]][k])[2]
  }

  data2 <- data
  x <- data2[[date]][1]
  if(!(is.numeric(x) && !inherits(x, "Date") && !inherits(x, "POSIXt"))){
    data2[[date]] <- as.Date(data2[[date]])
    fc[[date]] <- as.Date(fc[[date]])
  }

  # A. Identificamos el último punto real
  ultimo_dato_real <- tail(data2, 1)
  val_real_final   <- ultimo_dato_real[[value]]
  fecha_real_final <- ultimo_dato_real[[date]]
  
  # B. Creamos una fila "falsa" de predicción que es idéntica al dato real
  #    Esto sirve de puente para que plotly una las líneas
  fila_ancla <- fc[1, ] # Copiamos estructura de la primera fila de predicción
  
  fila_ancla[[date]] <- fecha_real_final # Misma fecha que el último real
  fila_ancla$.mean   <- val_real_final   # El valor es el real
  fila_ancla$lower   <- val_real_final   # Límite inf = valor real (sin margen)
  fila_ancla$upper   <- val_real_final   # Límite sup = valor real (sin margen)
  
  # C. Pegamos esta fila AL PRINCIPIO de la predicción
  fc <- dplyr::bind_rows(fila_ancla, fc)


p <- plot_ly() %>%
  add_ribbons(x = fc[[date]], ymin = fc$lower, ymax = fc$upper,
              name = "95% CI", fillcolor = "rgba(0,0,150,0.2)", line = list(width = 0)) %>%
  add_lines(x=fc[[date]], y = fc$.mean, name = "Predicción", line = list(color = "blue")) %>%
  add_lines(x=data2[[date]], y = data2[[value]], name = "Observación", line = list(color = "black")) %>%
  layout(
      # Fuente Sans (Arial) y color gris oscuro (#333333)
      font = list(family = "Arial, sans-serif", color = "#333333"),
      
      # Fondo blanco puro
      paper_bgcolor = "#ffffff",
      plot_bgcolor  = "#ffffff",
      
      # Título en negrita
      title = list(
        text = paste0("<b>", TITLE, "</b>"), 
        font = list(size = 25),
        x = 0.5, 
        xanchor = "center",
        yanchor = "top"
      ),
      
      # Eje X: Cuadrícula gris suave (#dee2e6) y sin bordes negros
      xaxis = list(
        title = list(text = "<b>Año</b>", font = list(size = 17)), 
        showgrid = TRUE,
        gridcolor = "#dee2e6", 
        zeroline = FALSE,
        showline = FALSE,
        tickfont = list(color = "#555555"),
        range(100, 200)
      ),
      
      # Eje Y: Igual que el X
      yaxis = list(
        title = list(text = "<b>Valor</b>", font = list(size = 17)),
        showgrid = TRUE,
        gridcolor = "#dee2e6",
        zeroline = FALSE,
        showline = FALSE,
        tickfont = list(color = "#555555")
      ),
      
      # Leyenda 
      legend = list(
        font = list(weight = "bold", size=15),
        orientation = "v",   # Vertical
        x = 1.02,            # Justo fuera del gráfico a la derecha
        y = 1,               # Alineada arriba
        xanchor = "left",
        yanchor = "top",
        bgcolor = "rgba(0,0,0,0)"
      ),
      
      # Márgenes ajustados
      margin = list(t = 60, b = 40, l = 20, r = 160)
    )



return(p)
}

#FUNCIÓN PARA DIBUJAR UN MAPA COROPLÉTICO USANDO leaflet
MapaCoroplético <- function(
 geoj, # objeto gráfico geojson con los contornos de las regiones
 value, # vector de valores para colorear 
 region_labels, # vector de etiquetas para los desplegables
 legend_title # título de la leyenda 
){

vals <- value[!is.na(value)]

pal <- colorNumeric(
  palette = "YlOrRd",
  domain  = vals
)

p <-  geoj %>%
    leaflet() %>%  
    setView(lng = 10, lat = 48, zoom = 4)  %>% 
    addPolygons(
        fillColor = ~pal(value),
        weight = 1,
        opacity = 1,
        color = "#555555",
        dashArray = "",
        fillOpacity = 0.75,
        highlightOptions = highlightOptions(
            weight = 3,
            color = "#333333",
            dashArray = "",
            fillOpacity = 0.8,
            bringToFront = TRUE
        ),
      label = region_labels 
    ) %>% 
    addLegend("bottomleft", 
      pal = pal, 
      values = value,
      title = legend_title,
      labFormat = function(type, cuts, p) {
        n = length(cuts) 
        x = (cuts[-n] + cuts[-1])/2
        x = prettyNum(round(x, digits = 0), big.mark = " ")
        as.character(x)
      },
 
      opacity = 1
      )
  return(p)
}



# CÁLCULO DE LA TRANSFORMACIÓN DE YEO–JOHNSON A PARTIR DE UN VECTOR Y UN VALOR DE lambda 
yeo.johnson <- function(y, lambda) {
  y_t <- numeric(length(y))
  
  # Para y >= 0
  pos_idx <- which(y >= 0)
  if (lambda == 0) {
    y_t[pos_idx] <- log(y[pos_idx] + 1)
  } else {
    y_t[pos_idx] <- ((y[pos_idx] + 1)^lambda - 1) / lambda
  }
  
  # Para y < 0
  neg_idx <- which(y < 0)
  if (lambda == 2) {
    y_t[neg_idx] <- -log(-y[neg_idx] + 1)
  } else {
    y_t[neg_idx] <- -(((-y[neg_idx] + 1)^(2 - lambda) - 1) / (2 - lambda))
  }
  
  return(y_t)
}


# ESTIMACIÓN DE lambda PARA LA TRANSFORMACIÓN DE YEO–JOHNSON DE UN VECTOR y
# OPTIMIZANDO  EL R2 DE LA REGRESIÓN LINEAL CON UN VECTOR x.  
optimize.yeojohnson.R2 <- function(x, y, lambda_range = c(-1, 1.9)) {
 
  # Función objetivo: R² negativo (porque optimize minimiza)
  r2_neg <- function(lambda) {
    y_t <- yeo.johnson(y, lambda)
    modelo <- lm(y_t ~ x)
    return(-summary(modelo)$r.squared)  # queremos maximizar R²
  }
  
  # Optimización de lambda
  opt <- optimize(r2_neg, interval = lambda_range)
  
  # Se retorna el valor óptimo de lambda 
  return(opt$minimum)
}

# FUNCIÓN PARA DIBUJAR LA MATRIZ DE CORRELACIÓN
plot_correlation <- function(
M, # matriz de correlación
show_values = TRUE # flat para controlar si se imprimen los valores en las celdas
) {
  
  # Texto dentro de la celda (2 decimales)
  cell_text <- round(M, 2)
  
  # Escala personalizada: rojo -> blanco -> azul
  custom_colors <- list(
    c(0, "red"),    # mínimo (-1) → azul
    c(0.5, "white"),# 0 → blanco
    c(1, "steelblue")    # máximo (+1) → rojo
  )
  
  # Crear heatmap interactivo
  plot_ly(
    x = colnames(M),
    y = rownames(M),
    z = M,
    type = "heatmap",
    colorscale = custom_colors,
    zmin = -1,
    zmax = 1,
    text = if (show_values) cell_text else NULL,
    texttemplate = if (show_values) "%{text}" else NULL,
    textfont = list(color = "black"),
    hovertemplate = "X: %{x}<br>Y: %{y}<br>Correlación: %{z:.4f}<extra></extra>"
  ) %>%
    layout(
      title = "Matriz de correlación interactiva",
      xaxis = list(title = "", tickangle = 45),
      yaxis = list(title = "", autorange = "reversed")
    )
}
```
```{r estilo-graficas, include=FALSE}
# Configuramos el tema sin especificar familia de fuente (usará la estándar)
theme_set(
  theme_minimal() + 
  theme(
    # --- TEXTO GENERAL ---
    # Solo definimos el color gris oscuro para que coincida con tu CSS
    text = element_text(color = "#333333"),
    
    # --- TÍTULOS DE GRÁFICO ---
    plot.title = element_text(face = "bold", size = 16, hjust = 0.5, margin = margin(b = 10)),
    plot.subtitle = element_text(face = "italic", size = 12, hjust = 0.5, color = "#666666"),
    
    # --- EJES ---
    axis.title = element_text(face = "bold", size = 12),
    axis.text = element_text(size = 10, color = "#555555"),
    
    # --- LEYENDA ---
    legend.position = "top",
    legend.title = element_text(face = "bold", size = 11),
    legend.text = element_text(size = 10),
    
    # --- FACETAS (Títulos de las cajitas de países - strip) ---
    # Esto es clave para que tu gráfica de múltiples países se vea bien
    strip.text = element_text(face = "bold", size = 11, color = "#333333"),
    strip.background = element_rect(fill = "#f8f9fa", color = NA), # Fondo gris muy suave para el título
    
    # --- FONDO Y CUADRÍCULA (Coincide con el CSS) ---
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA),
    panel.grid.major = element_line(color = "#dee2e6", size = 0.4), # Gris suave
    panel.grid.minor = element_blank(),
    plot.margin = margin(15, 15, 15, 15)
  )
)

# --- Actualizar textos DENTRO del gráfico (geom_text) ---
# Quitamos cualquier referencia a familias de fuente aquí también
update_geom_defaults("text", list(color = "#333333"))
update_geom_defaults("label", list(color = "#333333"))

```
```{css, echo=FALSE}
/* 1. PALETA DE COLORES NEUTRA */
:root {
  --main-color: #343a40;        /* Gris Oscuro para Header */
  --accent-color: #007bff;      /* Azul Estándar (Sólo para Hover/Activo) */
  --text-color-dark: #333333;   /* Gris Oscuro para Texto Principal y Inputs */
  --light-bg: #f8f9fa;          /* Fondo muy, muy claro */
  --sidebar-bg: #ffffff;        /* Fondo Blanco para Sidebar (limpio) */
  --card-bg: #ffffff;           /* Fondo Blanco para Paneles/Gráficos */
  --border-color: #dee2e6;       /* Gris muy claro para bordes */
  --border-radius-soft: 8px;    /* Radio de Borde Suave */
}

/* 2. ESTILO DEL CUERPO Y FUENTE (Open Sans) */
body {
  font-family: 'Open Sans', sans-serif;
  background-color: var(--light-bg);
  color: var(--text-color-dark);
}

/* 3. SIDEBAR Y TÍTULOS DE INPUTS */
.main-sidebar {
  background-color: var(--sidebar-bg) !important;
  box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.05);
  border-right: 1px solid var(--border-color);
}

/* Asegura que los títulos de los inputs sean oscuros */
.shiny-input-container label, .form-group label {
  color: var(--text-color-dark) !important;
  font-weight: 600;
  padding-bottom: 5px;
}

/* Ajuste para que el texto no toque el triangulito */
/* 1. Hacemos hueco para el triangulo (Padding derecho) */
.selectize-input {
    padding-right: 28px !important; /* Espacio reservado para la flecha */
    white-space: nowrap !important; /* Obliga a que sea una sola línea */
}

/* 2. Cortamos el texto elegantemente con puntos suspensivos (...) */
.selectize-input > .item {
    /*display: block !important;     /* Necesario para que funcione el corte */
    overflow: hidden !important;   /* Oculta lo que sobra */
    text-overflow: ellipsis !important; /* Añade los tres puntos */
    width: 100% !important;        /* Ocupa todo el ancho disponible (menos el padding) */
}

.selectize-control.multi .selectize-input {
    white-space: normal !important; /* PERMITE saltar de línea */
    height: auto !important;        /* PERMITE crecer verticalmente */
    overflow: visible !important;   /* Que se vean todas las etiquetas */
}

/* Reseteamos el comportamiento de los items (las etiquetas de países) */
.selectize-control.multi .selectize-input > .item {
    display: inline-block !important; /* Que se pongan uno al lado del otro */
    width: auto !important;           /* Que ocupen solo lo que mida el texto */
    margin-right: 3px !important;     /* Un poco de aire entre etiquetas */
    margin-bottom: 2px !important;    /* Aire vertical */
}

/* 4. ENCABEZADO SUPERIOR (HEADER) */
.navbar {
  background-color: var(--main-color) !important;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  border-bottom: none;
}

.navbar-brand, .navbar-nav > li > a {
  color: #ffffff !important;
  font-weight: 600;
}

.navbar-nav > li.active > a,
.navbar-nav > li.active > a:hover,
.navbar-nav > li.active > a:focus {
  background-color: #495057 !important;
  border-bottom: 3px solid var(--accent-color);
}

/* 5. CONTROLES/INPUTS (SHINY NATIVOS) - Redondeados, Legibles y Discretos */

/* Aplica a selectInput, numericInput, sliderInput, etc. */
.form-control {
  border-radius: var(--border-radius-soft) !important;
  border: 1px solid var(--border-color);
  box-shadow: none;
  /* Asegura el color de texto para todos los inputs */
  color: var(--text-color-dark) !important; 
  background-color: #ffffff !important; /* Fondo siempre blanco para contraste */
}

/* Estilo para el foco (el resaltado cuando el input está activo) */
.form-control:focus {
  border-color: var(--accent-color) !important;
  box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
}


/* Estilo para los botones de las pestañas laterales (e.g., NUTS) */
.btn-default {
  border-radius: var(--border-radius-soft);
  border: 1px solid var(--border-color);
  background-color: #ffffff;
}

.btn-default.active {
  background-color: var(--accent-color);
  color: #ffffff;
  border-color: var(--accent-color);
}

.btn-default:hover {
  background-color: #e9ecef;
}

/* 6. PANELES Y CAJAS (para los gráficos) */
.box {
  background-color: var(--card-bg);
  border-radius: var(--border-radius-soft);
  box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.05); 
  padding: 15px; 
}

/* 7. TÍTULOS DE PANELES */
.flexdashboard .panel-title {
  color: var(--text-color-dark); 
  font-weight: 600;
  border-bottom: 1px solid var(--border-color);
  padding-bottom: 5px;
  margin-bottom: 10px;
}

/* --- ESTILO PARA CAJAS DE MÉTRICAS (RMSE, MODELO) --- */
.box-metricas {
  /* Fondo y borde similar al de los inputs/botones */
  background-color: var(--card-bg); /* Blanco */
  border: 1px solid var(--border-color); /* Borde gris suave */
  border-radius: var(--border-radius-soft); /* Bordes redondeados */
  padding: 10px 15px; /* Espacio interno */
  margin-bottom: 15px; /* Espacio debajo */
  box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.03); /* Sombra muy sutil */
  text-align: left; /* Alineación del texto */
}

/* Estilo para las etiquetas (RMSE, Modelo Seleccionado) */
.box-metricas h4 {
  color: var(--text-color-dark); /* Color de texto oscuro */
  font-family: 'Open Sans', sans-serif;
  font-weight: 600; /* Semi-negrita para destacar */
  font-size: 14px;
  margin-top: 0;
  margin-bottom: 5px; /* Espacio debajo de la etiqueta */
}

/* Estilo para los valores numéricos/modelos */
.box-metricas h2, .box-metricas h3 {
  color: var(--main-color); /* Usa el color principal del header (gris oscuro) para el valor */
  font-family: 'Open Sans', sans-serif;
  font-weight: 300; /* Negrita */
  margin-top: 0;
  font-size: 18px;
  margin-bottom: 0;
  line-height: 1.1; /* Espacio de línea ajustado */
}
```


<!-- Carga inicial de los datos -->
```{r analisis-data-raw, results=F}
data_raw <- read_csv('data/nama_10r_2lp10.csv') %>% 
    as_tibble()

data_raw
```
```{r analisis-inicial, results=F}
real_names <- read_csv('data/eurostac_real_nuts.csv') %>% 
    as_tibble()


data <- data_raw %>% 
    select(-freq) %>% 
    rename(year = TIME_PERIOD, sector = nace_r2, item = na_item) %>% 
    left_join(real_names, by='geo') %>% 
    select(geo, NUTS, full_name, year, sector, item, unit, values) %>% 
    mutate(sector_name = case_when(
        sector == "TOTAL" ~ "Total actividades",
        sector == "O-U" ~ "Adm. pública, educación y salud",
        sector == "O-Q" ~ "Adm. pública, defensa y educación",
        sector == "B-E" ~ "Industria",
        sector == "K-N" ~ "Finanzas e inmobiliarias",
        sector == "F" ~ "Construcción",
        sector == "M_N" ~ "Profesionales y científicas",
        sector == "A" ~ "Agricultura y pesca",
        sector == "C" ~ "Manufactura",
        sector == "G-J" ~ "Comercio y transporte",
        sector == "R-U" ~ "Artes y otros servicios",
        sector == "G-I" ~ "Comercio y alojamiento",
        sector == "J" ~ "Información y comunicación",
        sector == "K" ~ "Finanzas",
        sector == "L" ~ "Inmobiliarias",
        TRUE ~ "Otro"
        )) %>% 
    relocate(sector_name, .after=sector)
    

data
```
```{r archivos-geoj, results=F}
# Carga de datos geográficos locales (mucho más rápido)
geoj0 <- readRDS("data/geoj0.rds")
geoj1 <- readRDS("data/geoj1.rds")
geoj2 <- readRDS("data/geoj2.rds")

geoj0.tb <- geoj0 %>% as_tibble()
geoj1.tb <- geoj1 %>% as_tibble()
geoj2.tb <- geoj2 %>% as_tibble()
```

viejo
=================
```{r ST_paises-analisis-data}
filtrado_series_temporales <- reactive({
    tb <- data %>% 
        filter(item == input$indicador, unit == input$unidad, sector_name == input$sector)
    return(tb)
})
```

```{r ST_paises-widgets-seleccion}
# --- Relación entre indicadores (códigos del dataset) y las unidades disponibles ---
indicador_unidades <- list(
    "D1_SAL_PER" = c("EUR", "NAC", "PC_EU27_2020_MEUR_CP"),
    "D1_SAL_HW"  = c("EUR", "NAC", "PC_EU27_2020_MEUR_CP"),
    "HW_EMP"     = c("HW", "PCH_PRE")
)

# --- Nombres descriptivos para mostrar en el selector ---
indicadores_labels <- c(
    "Coste laboral medio / persona" = "D1_SAL_PER",
    "Coste laboral / hora trabajada" = "D1_SAL_HW",
    "Horas trabajadas en promedio" = "HW_EMP"
)

unidad_labels <- c(
    "EUR" = "EUR",
    "Moneda nacional" = "NAC",
    "Porcentaje UE27" = "PC_EU27_2020_MEUR_CP",
    "Var. porcentual" = "PCH_PRE",
    "Horas anuales" = "HW"
)

# --- Selectores de parámetros ---
div(
    style = "display: flex; align-items: center; gap: 30px;", # Misma línea, separación 30px
  
    # - Indicador -
    div(
        selectInput(
            "indicador",
            label = "Indicador:",
            choices = indicadores_labels,
            selected = "Coste laboral medio / persona"
        )
    ),
  
    # - Unidad -
    div(
        selectInput(
            "unidad",
            label = "Unidad:",
            choices = unidad_labels,
            selected = "EUR"
        )
    ),
  
   # - Sector -
    div(
        selectInput(
            inputId = "sector",
            label = "Sector:",
            choices = c("Total actividades", sort(setdiff(unique(data$sector_name), "Total actividades"))),
            selected = "Total actividades"           
        )
    ),
  
    # Condicional para la comparativa de países
    conditionalPanel(
        # La 'condition' es una expresión de JavaScript.
        condition = "input.ID_DE_TUS_PESTAÑAS == 'Comparativa países'",
    
        div( # Lo envuelvo en un div para que sea un "hijo" del flexbox
            selectInput(
                inputId = "paises_seleccion",
                label = "Selecciona países:",
                choices = data %>% 
                    filter(NUTS==0) %>% 
                    pull(full_name) %>%
                    unique() %>%
                    sort(),
            multiple = TRUE,
            selected = "Spain"
            )
        )
    ),
  
    # Condicional para la comparativa de CCAA
    conditionalPanel(
        # La 'condition' es una expresión de JavaScript.
        condition = "input.ID_DE_TUS_PESTAÑAS == 'Comparativa CCAA'",
    
        div( # Lo envuelvo en un div para que sea un "hijo" del flexbox
            selectInput(
                inputId = "ccaa_seleccion",
                label = "Selecciona comunidades:",
                choices = data %>% 
                    filter((substr(geo, 1, 2) == "ES" & NUTS == 2)) %>% 
                    pull(full_name) %>%
                    unique() %>%
                    sort(),
            multiple = TRUE,
            selected = "Canarias"
            )
        )
    )
)


# --- Para que no se puedan seleccionar unidades que no existen ---
observe({
    req(input$indicador) # Confirmamos que haya algo seleccionado
    
    # obtén el código del indicador seleccionado (por ejemplo "D1_SAL_HW")
    indicador_sel <- input$indicador
    
    # busca las unidades válidas para ese indicador
    unidades_validas <- indicador_unidades[[indicador_sel]]
    
    # filtra tus etiquetas de unidades (para mostrar solo las disponibles)
    unidades_filtradas <- unidad_labels[unidad_labels %in% unidades_validas]
    
    # actualiza el selector de unidad con esas opciones
    updateSelectInput(
        inputId = "unidad",
        choices = unidades_filtradas,
        selected = unidades_filtradas[1]
    )
})

# --- Para que no se puedan seleccionar sectores que no existen ---
observe({
    req(input$indicador, input$unidad) # Confirmamos que haya algo seleccionado
    
    # Filtramos los datos disponibles con los inputs actuales
    sectores_disponibles <- data %>%
        filter(
            item == input$indicador,
            unit == input$unidad
        ) %>%
        pull(sector_name) %>%
        unique() %>%
        sort()

    # Actualizamos las opciones del selector de sector
    updateSelectInput(
        inputId = "sector",
        choices = c("Total actividades", sort(setdiff(unique(sectores_disponibles), "Total actividades"))),
        selected = "Total actividades"
      )
})
```


Column {.tabset}
--------------------------------------------------
```{r ST_paises-agrupaciones-paises}
# España y Canarias
referencia <- c("ES", "ES7")

paises_principales <- c(
  referencia,
  "DE", # Alemania
  "FR", # Francia
  "IT", # Italia
  "NL", # Países Bajos
  "BE", # Bélgica
  "SE", # Suecia
  "PL", # Polonia
  "AT", # Austria
  "DK", # Dinamarca
  "IE", # Irlanda
  "PT", # Portugal
  "CZ", # Chequia
  "HU", # Hungría
  "LU"  # Luxemburgo
)

paises_resto <- c(
  referencia,
  "BG", # Bulgaria
  "HR", # Croacia
  "CY", # Chipre
  "EE", # Estonia
  "EL", # Grecia
  "LT", # Lituania
  "LV", # Letonia
  "FI", # Finlandia
  "MT", # Malta
  "SI", # Eslovenia
  "RO", # Rumanía
  "SK", # Eslovaquia
  "RS", # Serbia
  "MK"  # Macedonia del Norte
)
```

### Países 1
```{r ST_paises-paises1}
# Países 1
renderPlotly({
  tb <- filtrado_series_temporales()
    
  tb %>% 
    filter(geo %in% paises_principales) %>%
    mutate(full_name = factor(full_name,  # Poner Canarias y España primero
                       levels = c("Canarias", "Spain",
                                  setdiff(unique(full_name), c("Canarias", "Spain"))))) %>%
    ggplot(aes(year,y=values)) +
    geom_line() +
    facet_wrap(~full_name,scales = "free_y",ncol=4) +
    theme(axis.text.x = element_text(angle = 45,hjust=1)) + 
    labs(x="",y="")
})
```

### Países 2
```{r ST_paises-paises2}
# Países 2
renderPlotly({
  tb <- filtrado_series_temporales()
    
  tb %>% 
    filter(geo %in% paises_resto) %>%
    mutate(full_name = factor(full_name,  # Poner Canarias y España primero
                       levels = c("Canarias", "Spain",
                                  setdiff(unique(full_name), c("Canarias", "Spain"))))) %>%
    ggplot(aes(year,y=values)) +
    geom_line()+
    facet_wrap(~full_name,scales = "free_y",ncol=4) +
    theme(axis.text.x = element_text(angle = 45,hjust=1)) + 
    labs(x="",y="")
})
```

### CCAA
```{r ST_paises-ccaa}
renderPlotly({
  tb <- filtrado_series_temporales()
    
  tb %>% 
    filter((substr(geo, 1, 2) == "ES" & NUTS == 2) | geo == "ES") %>%
    mutate(full_name = factor(full_name, # Poner Canarias y España primero
                       levels = c("Canarias", "Spain",
                                  setdiff(unique(full_name), c("Canarias", "Spain"))))) %>%
    ggplot(aes(year, y = values)) +
    geom_line() +
    facet_wrap(~full_name, scales = "free_y", ncol = 4) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(x = "", y = "")
})
```

### Comparativa países
```{r ST_paises-input-comparativa-paises}
selectInput(
    inputId = "paises_seleccion",
    label = "Selecciona países:",
    choices = data %>% 
        filter(NUTS==0) %>% 
        pull(full_name) %>%
        unique() %>%
        sort(),
    multiple = TRUE,
    selected = "Spain",
)
```

```{r ST_paises-comparativa-paises}
div(renderHighchart({
      req(input$paises_seleccion, input$indicador, input$unidad) # Validar que los inputs no estén vacíos
      
    # 1. Datos de las CCAA (del input)
      data_paises <- filtrado_series_temporales() %>%
        filter(
          full_name %in% input$paises_seleccion,
          item == input$indicador,
          unit == input$unidad
        ) %>%
        arrange(year)
        
      # 2. Datos de EU27 (siempre)
      data_eu <- filtrado_series_temporales() %>%
        filter(
          geo == "EU27_2020", 
          item == input$indicador,
          unit == input$unidad
        ) %>%
        arrange(year)
    
      # 3. Gráfico base (con CCAA) y añadir serie de España
      hchart(
        data_paises, # Gráfico base con las CCAA seleccionadas
        type = "line",
        hcaes(x = year, y = values, group = full_name),
        marker = list(enabled = TRUE)
      ) %>%
      
        hc_add_series(
          data = data_eu,          
          type = "line",
          hcaes(x = year, y = values),
          name = "Media UE (Referencia)",
          dashStyle = "Dash",   
          color = "lightgrey",  
          marker = list(enabled = FALSE) 
        ) %>%
        hc_title(text = "") %>%
        hc_xAxis(title = list(text = NULL)) %>%
        hc_yAxis(title = list(text = NULL)) %>%
        hc_legend(enabled = TRUE) %>% 
        hc_chart(height = 500)
    })
)

```

### Comparativa CCAA
```{r ST_paises-input-comparativa-ccaa}
# Selector de comunidades
selectInput(
    inputId = "ccaa_seleccion",
    label = "Selecciona comunidades:",
    choices = data %>% 
        filter((substr(geo, 1, 2) == "ES" & NUTS == 2)) %>% 
        pull(full_name) %>%
        unique() %>%
        sort(),
    multiple = TRUE,
    selected = "Canarias",
)
```

```{r ST_paises-comparativa-ccaa}
div(renderHighchart({
      req(input$ccaa_seleccion, input$indicador, input$unidad) # Validar que los inputs no estén vacíos
      
    # 1. Datos de las CCAA (del input)
      data_ccaa <- filtrado_series_temporales() %>%
        filter(
          full_name %in% input$ccaa_seleccion, # Asumimos que "Spain" no viene aquí
          item == input$indicador,
          unit == input$unidad
        ) %>%
        arrange(year)
        
      # 2. Datos de España (siempre)
      data_espana <- filtrado_series_temporales() %>%
        filter(
          full_name == "Spain", 
          item == input$indicador,
          unit == input$unidad
        ) %>%
        arrange(year)
    
      # 3. Gráfico base (con CCAA) y añadir serie de España
      hchart(
        data_ccaa, # Gráfico base con las CCAA seleccionadas
        type = "line",
        hcaes(x = year, y = values, group = full_name),
        marker = list(enabled = TRUE)
      ) %>%
      
        hc_add_series(
          data = data_espana,          
          type = "line",
          hcaes(x = year, y = values),
          name = "España (Referencia)",
          dashStyle = "Dash",   
          color = "lightgrey",  
          marker = list(enabled = FALSE) 
        ) %>%
        hc_title(text = "") %>%
        hc_xAxis(title = list(text = NULL)) %>%
        hc_yAxis(title = list(text = NULL)) %>%
        hc_legend(enabled = TRUE) %>% 
        hc_chart(height = 500)
    })
)
```


Mapa coroplético
================

Column {.sidebar data-width=285}
--------------------------------------------------

```{r widgets-mapa}
# Widgets para selección de parámetros 
selectInput(
    "indicador_mapa",
    label = "Indicador:",
    choices = indicadores_labels,
    selected = "Coste laboral medio / persona"
)

selectInput(
    "unidad_mapa",
    label = "Unidad:",
    choices = unidad_labels,
    selected = "EUR"
)

selectInput(
    "sector_mapa",
    label = "Sector:",
    choices = c("Total actividades", sort(setdiff(unique(data$sector_name), "Total actividades"))), # Total primero
    selected = "Total actividades"           
)


sliderInput(
    inputId = "year_mapa",
    label = "Año de inicio datos:",
    min = 1995, 
    max = 2023, 
    value = 2023,
    step = 1,
    sep = "",
    ticks = FALSE
)

radioButtons(
  inputId = "nuts_mapa",
  label = "NUTS:",
  choices = 0:2,
  selected = 0,
  inline = TRUE
  
)

opciones_mapa <- data %>%
    filter(NUTS == 0) %>%
    select(full_name, geo) %>% 
    distinct() %>%
    arrange(full_name) %>%
    tibble::deframe()

selectInput(
    inputId = "seleccion_mapa",
    label = "Selecciona país(es):",
    choices = opciones_mapa,
    selected = NULL,      # <-- Perfecto, empieza vacío
    multiple = TRUE,      # <-- La clave 1: permite selección múltiple
)


# --- Para que no se puedan seleccionar unidades que no existen ---
observe({
    req(input$indicador_mapa) # Confirmamos que haya algo seleccionado
    
    # obtén el código del indicador seleccionado (por ejemplo "D1_SAL_HW")
    indicador_sel <- input$indicador_mapa
    
    # busca las unidades válidas para ese indicador
    unidades_validas <- indicador_unidades[[indicador_sel]]
    
    # filtra tus etiquetas de unidades (para mostrar solo las disponibles)
    unidades_filtradas <- unidad_labels[unidad_labels %in% unidades_validas]
    
    # actualiza el selector de unidad con esas opciones
    updateSelectInput(
        inputId = "unidad_mapa",
        choices = unidades_filtradas,
        selected = unidades_filtradas[1]
    )
})

# --- Para que no se puedan seleccionar sectores que no existen ---
observe({
    req(input$indicador_mapa, input$unidad_mapa) # Confirmamos que haya algo seleccionado
    
    # Filtramos los datos disponibles con los inputs actuales
    sectores_disponibles <- data %>%
        filter(
            item == input$indicador_mapa,
            unit == input$unidad_mapa
        ) %>%
        pull(sector_name) %>%
        unique() %>%
        sort()

    # Actualizamos las opciones del selector de sector
    updateSelectInput(
        inputId = "sector_mapa",
        choices = c("Total actividades", sort(setdiff(unique(sectores_disponibles), "Total actividades"))),
        selected = "Total actividades"
      )
})

observe({
  # 1. Esperamos a tener todos los inputs necesarios
  req(
    input$indicador_mapa,
    input$unidad_mapa,
    input$sector_mapa,
    input$year_mapa
  )
  
  # 2. Filtramos 'data' para encontrar qué países (NUTS 0)
  #    tienen observaciones (values) NO nulas
  #    para la combinación de filtros actual.
  
  paises_con_datos <- data %>%
    filter(
      item == input$indicador_mapa,
      unit == input$unidad_mapa,
      sector_name == input$sector_mapa,
      year == input$year_mapa,
      NUTS == 0,           # Filtramos solo por países
      !is.na(values)       # ¡La clave! Solo los que tienen datos
    ) %>%
    select(full_name, geo) %>% # Seleccionamos el nombre y el ID
    distinct() %>%
    arrange(full_name)
  
  # 3. Creamos el vector nombrado ("Nombre" = "ID")
  opciones_disponibles <- tibble::deframe(paises_con_datos)
  
  # 4. (Opcional pero recomendado) Mantenemos la selección actual
  #    si los países seleccionados siguen estando en la nueva lista.
  
  # Guardamos la selección actual
  seleccion_actual <- isolate(input$seleccion_mapa)
  
  # Vemos cuáles de los seleccionados siguen siendo válidos
  # Usamos 'opciones_disponibles' (el vector nombrado) para 
  # comprobar contra los 'valores' (los códigos "geo")
  nueva_seleccion <- intersect(seleccion_actual, opciones_disponibles)
  
  # Si la intersección da un vector vacío, lo ponemos como NULL
  # para que el selectInput muestre "Ningún país seleccionado"
  if (length(nueva_seleccion) == 0) {
    nueva_seleccion <- NULL
  }

  # 5. Actualizamos el selectInput
  updateSelectInput(
    inputId = "seleccion_mapa",
    choices = opciones_disponibles,
    selected = nueva_seleccion # Usamos la selección preservada
  )
  
})
```

<!-- Funciones reactive --> 

```{r funciones-mapa}
inputs.processing.mapa0 <- reactive({
    req(input$indicador_mapa, input$unidad_mapa, input$sector_mapa, input$year_mapa)
    
    etiqueta_valida <- paste(
        names(indicadores_labels)[match(input$indicador_mapa, indicadores_labels)], 
        "-",
        names(unidad_labels)[match(input$unidad_mapa, unidad_labels)]
    )
    
  tb <- geoj0.tb %>% 
    left_join(
      data %>%
        filter(year==input$year_mapa, item==input$indicador_mapa, unit==input$unidad_mapa, sector_name==input$sector_mapa, NUTS=="0", is.null(input$seleccion_mapa) | (geo %in% input$seleccion_mapa)),
      join_by("NUTS_ID"=="geo")
    ) %>% 
    mutate(full_name = coalesce(full_name, NAME_LATN),
           # crear etiqueta legible combinando indicador y unidad
            indicador_unidad = etiqueta_valida
    )
  
  return(tb)
})
inputs.processing.mapa1 <- reactive({
    req(input$indicador_mapa, input$unidad_mapa, input$sector_mapa, input$year_mapa)
    
    etiqueta_valida <- paste(
        names(indicadores_labels)[match(input$indicador_mapa, indicadores_labels)], 
        "-",
        names(unidad_labels)[match(input$unidad_mapa, unidad_labels)]
    )
        
  tb <- geoj1.tb %>% 
    left_join(
      data %>%
        filter(year==input$year_mapa, item==input$indicador_mapa, unit==input$unidad_mapa, sector_name==input$sector_mapa, NUTS=="1",is.null(input$seleccion_mapa) | (substr(geo, 1, 2) %in% input$seleccion_mapa)),
      join_by("NUTS_ID"=="geo")
    ) %>% 
    mutate(full_name = coalesce(full_name, NAME_LATN),
           # crear etiqueta legible combinando indicador y unidad
            indicador_unidad = etiqueta_valida
    )
  return(tb)
})

inputs.processing.mapa2 <- reactive({
    req(input$indicador_mapa, input$unidad_mapa, input$sector_mapa, input$year_mapa)
    
    etiqueta_valida <- paste(
        names(indicadores_labels)[match(input$indicador_mapa, indicadores_labels)], 
        "-",
        names(unidad_labels)[match(input$unidad_mapa, unidad_labels)]
    )
    tb <- geoj2.tb %>% 
        left_join(
        data %>%
        filter(year==input$year_mapa, item==input$indicador_mapa, unit==input$unidad_mapa, sector_name==input$sector_mapa, NUTS=="2", is.null(input$seleccion_mapa) | (substr(geo, 1, 2) %in% input$seleccion_mapa)),
      join_by("NUTS_ID"=="geo")
    ) %>% 
    mutate(full_name = coalesce(full_name, NAME_LATN),
           # crear etiqueta legible combinando indicador y unidad
            indicador_unidad = etiqueta_valida
    )
  
  return(tb)
})
```

### 

<!--Tabla-->
```{r tabla-mapa}
# imprimimos la tabla con el atributo seleccionado 
renderTable({
  tb <- switch (input$nuts_mapa,
      "0" =  inputs.processing.mapa0(),
      "1" =  inputs.processing.mapa1(),
      "2" =  inputs.processing.mapa2()
  )
  
 tb %>% 
    arrange(desc(values))%>%  
    select(full_name,values) %>% 
    filter(!is.na(values)) %>% 
    mutate(Valor=prettyNum(round(values,
    digits=max(5-nchar(as.character(round(max(na.omit(values))))),0)),
    big.mark = ",")) %>% 
    select(Región = full_name, Valor)
 
})
```

Column {.tabset}
--------------------------------------------------

### Mapa Coroplético

```{r renderizado-mapa}
# dibujamos el mapa coroplético
leaflet::renderLeaflet({
    req(input$indicador_mapa, input$unidad_mapa, input$sector_mapa, input$year_mapa, input$nuts_mapa)
    
    # capturamos el resultado del procesado de los inputs 
    res <- switch(
        as.character(input$nuts_mapa),
        
        "0" = list(
            tb   = inputs.processing.mapa0(),
            geoj = geoj0
        ),
        "1" = list(
            tb   = inputs.processing.mapa1(),
            geoj = geoj1
        ),
        "2" = list(
            tb   = inputs.processing.mapa2(),
            geoj = geoj2
        )
    )

    tb   <- res$tb
    geoj <- res$geoj
    
    etiquetas <-paste(
        "<strong> ",tb$full_name ,
        "</strong><br>",tb$indicador_unidad,
        ": ",prettyNum(round(tb$values,digits=2), big.mark = ",", scientific = FALSE)
      )  %>%
     lapply(htmltools::HTML)
    
     # dibujamos el mapa 
     MapaCoroplético(geoj,tb$values,etiquetas,"Valor")
 
})
```


Comparación atributos
=====================

<!-- PRIMERA COLUMNA PARA SELECCIÓN DE PARÁMETROS Y MOSTRAR RESULTADOS 
  SOBRE LA REGRESIÓN LINEAL OBTENIDA ENTRE LAS VARIABLES --> 

Column {.sidebar data-width=310}
--------------------------------------------------

```{r data-compAtr}
data_comb <- data %>%
  mutate(
    # Buscamos el nombre humano del indicador usando tu vector (match busca el valor y devuelve el índice del nombre)
    nombre_item = names(indicadores_labels)[match(item, indicadores_labels)],
    
    # Buscamos el nombre humano de la unidad
    nombre_unit = names(unidad_labels)[match(unit, unidad_labels)],
    
    # --- CREAMOS EL ATRIBUTO COMBINADO (Lo que ve el usuario) ---
    # Ej: "Coste laboral / hora trabajada (EUR)"
    label_comb = paste0(nombre_item, " (", nombre_unit, ")"),
    
    # --- CREAMOS EL ID COMBINADO (Lo que usa el programa) ---
    # Usamos un separador raro "__" para poder separarlo luego fácil
    # Ej: "D1_SAL_HW__EUR"
    id_comb = paste(item, unit, sep = "__")
  )

# 2. Creamos el vector de opciones para el selector
#    Formato: c("Nombre Bonito" = "CODIGO__UNIDAD")
opciones_combinadas <- data_comb %>%
  select(label_comb, id_comb) %>%
  distinct() %>%
  arrange(label_comb) %>%
  tibble::deframe() # Convierte tabla de 2 columnas en vector nombrado
```

```{r widgets-compAtr}
# Widgets para selección de parámetros 
radioButtons(
  inputId = "ambito_ca",
  label = "Comparar por: ",
  choices = c("Indicadores", "Sectores laborales"),
  selected = "Indicadores"
)

conditionalPanel(
  condition = "input.ambito_ca == 'Sectores laborales'",
  selectInput(
    inputId = "ref_sector_mode",
    label = "Métrica a comparar:",
    # Filtramos solo las de Coste laboral por hora (tu requisito anterior)
    choices = opciones_combinadas[grep("D1_SAL_HW", opciones_combinadas)], 
    selected = opciones_combinadas[grep("D1_SAL_HW", opciones_combinadas)][1]
  )
)

selectInput(
  "x", 
  label = "x: atributo 1",
  choices = opciones_combinadas, 
  selected = opciones_combinadas[1] # Coste laboral / persona
)

selectInput(
  "x_scale", 
  label = "Transformación del atributo x",
  choices = c("none",
              "sqrt",    
              "log"
             ), 
  selected = "none"
)

selectInput(
  "y", 
  label = "y: atributo 2",
  choices = opciones_combinadas, 
  selected = opciones_combinadas[7] # Horas trabajadas
)

selectInput(
  "y_scale", 
  label = "Transformación del atributo y",
  choices = c("none",
              "log",
              "YeoJohnson"
             ), 
  selected = "none"
)

selectInput(
  "Año.Comparación.Atributos", 
  label = "Año",
  choices = c("Todos",2023:1995), 
  selected = "Todos"
)


observe({
   req(input$ambito_ca) # Esperamos a que exista el ámbito

   # Definimos las opciones dentro del observe para evitar errores de scope
   if (input$ambito_ca == "Sectores laborales") {
      # Si es sectores, cogemos los nombres únicos del data
      mis_opciones <- sort(unique(data$sector_name))
      etiqueta_x <- "Sector (X):"
      etiqueta_y <- "Sector (Y):"

   } else {
      # Si es indicadores, usamos tu vector 'indicadores_labels'
      mis_opciones <- indicadores_labels
      etiqueta_x <- "Indicador (X):"
      etiqueta_y <- "Indicador (Y):"
   }

   # Actualizamos input X
   updateSelectInput(
      inputId = "x",
      label = etiqueta_x,
      choices = mis_opciones,
      selected = mis_opciones[1]
   )

   # Actualizamos input Y (seleccionamos el 2º por defecto para variar)
   updateSelectInput(
      inputId = "y",
      label = etiqueta_y,
      choices = mis_opciones,
      selected = mis_opciones[2]
   )
})

observe({
   req(input$ambito_ca)
   
   if (input$ambito_ca == "Sectores laborales") {
      # --- MODO SECTORES ---
      # X e Y se convierten en selectores de SECTORES
      mis_opciones <- sort(unique(data$sector_name))
      etiqueta_x <- "Sector (X):"
      etiqueta_y <- "Sector (Y):"
      
   } else {
      # --- MODO VARIABLES ---
      # X e Y son tus variables combinadas
      mis_opciones <- opciones_combinadas
      etiqueta_x <- "Variable (X):"
      etiqueta_y <- "Variable (Y):"
   }

   # Actualizamos X
   updateSelectInput(inputId = "x", label = etiqueta_x, choices = mis_opciones, selected = mis_opciones[1])
   
   # Actualizamos Y
   # Dejamos en selected horas trabajadas vs remuneración si es por indicador
   sel_y <- ifelse(mis_opciones[1] == sort(unique(data$sector_name))[1], mis_opciones[2], mis_opciones[7])
   updateSelectInput(inputId = "y", label = etiqueta_y, choices = mis_opciones, selected = sel_y)
})
```

<!-- FUNCIÓN reactive PARA EL PROCESADO DE DATOS DE ESTA PÁGINA --> 

```{r funcion-compAtr}
# función reactive que calcula los indicadores seleccionados transformados, 
# en su caso, la transformación Yeo-Johnson entre ellos y
# la regresión lineal del resultado. 
# devuelve una lista con todo lo calculado
# hay que tener en cuenta que si input$Año != "Todos" hay que filtrar por el año seleccionado 
inputs.processing.comparacion.atributos <- reactive( {   
  # Validamos inputs
  req(input$x, input$y, input$Año.Comparación.Atributos)
  
  # 1. Preparación y filtro inicial
  df_base <- data_comb 
  
  if(input$Año.Comparación.Atributos != "Todos"){
    df_base <- df_base %>% filter(year == input$Año.Comparación.Atributos)
  } else {
    df_base <- df_base %>% filter(NUTS == 0) # quitamos regiones nuts 1 y 2 si mostramos todos los países
  }
  
  # 2. PIVOTAR (Con corrección para duplicados)
  if (input$ambito_ca == "Sectores laborales") {
    # --- MODO SECTORES ---
    req(input$ref_sector_mode)
    
    tb_wide <- df_base %>%
      filter(id_comb == input$ref_sector_mode) %>%     
      filter(sector_name %in% c(input$x, input$y)) %>%  
      select(year, full_name, sector_name, values) %>%
      # CORRECCIÓN AQUÍ: values_fn = mean asegura que devuelva un número, no una lista
      pivot_wider(names_from = sector_name, values_from = values, values_fn = mean)
      
  } else {
    # --- MODO VARIABLES ---
    tb_wide <- df_base %>%
      filter(id_comb %in% c(input$x, input$y)) %>%
      select(year, full_name, sector_name, id_comb, values) %>% 
      # CORRECCIÓN AQUÍ:
      pivot_wider(names_from = id_comb, values_from = values, values_fn = mean)
  }

  # 3. Renombrar y Limpiar
  #    Usamos un tryCatch o validación simple por si el pivot no genera las columnas esperadas
  #    (ej: si para un año no hay datos de una variable)
  
  # Verificamos que las columnas existan antes de renombrar
  if(!all(c(input$x, input$y) %in% names(tb_wide))) {
      return(NULL) # O manejar el error silenciosamente
  }

  tb <- tb_wide %>%
    rename(
      x = !!sym(input$x), 
      y = !!sym(input$y)
    ) %>%
    # OJO: Asegúrate de que 'full_name' es lo que quieres como 'municipio'
    select(year, full_name, x, y) %>%
    na.omit() # Quitamos NAs antes de procesar
    
  # Si tras el na.omit no quedan datos, paramos para evitar error en lm
  if(nrow(tb) == 0) return(NULL)
    
  # transformados los indicadores de acuerdo con los parámetros de la transformación
  if(input$x_scale=="sqrt") tb$x <- sign(tb$x)*sqrt(abs(tb$x))
  if(input$x_scale=="log") tb$x <-  sign(tb$x)*log(abs(tb$x))
  if(input$y_scale=="log") tb$y <-  sign(tb$y)*log(abs(tb$y))
  lambda <- 1  
  if(input$y_scale=="YeoJohnson"){
    lambda <- optimize.yeojohnson.R2(tb$x, tb$y) # Cálculo óptimo modelo Yeo-Jonhson 
    tb$y <- yeo.johnson(tb$y,lambda)
  }
  
  # Cálculo regresión lineal después de transformar las variables. 
  fit <- lm(y ~ x,data=tb)
  
  # devolvemos una lista con todo lo calculado 
  return(list(tb,fit,lambda))
})
``` 

### 

```{r métricas-compAtr}
renderUI({
  req(inputs.processing.comparacion.atributos())
  resultado <- inputs.processing.comparacion.atributos()
  
  tb     <- resultado[[1]]
  fit    <- resultado[[2]]
  lambda <- resultado[[3]]

  # 1. Construimos el texto HTML (Casi igual que lo tenías)
  texto_html <- paste0(
    "<h3>Linear Regression Analysis</h3>",
    "<strong>Formula:</strong> y = ax + b <br>",
    "<strong>x:</strong> Atributo 1 (scaled)<br>",
    "<strong>y:</strong> Atributo 2 (scaled)<br>",
    "<hr style='margin: 10px 0; border-top: 1px solid #ccc;'>", # Línea separadora sutil
    "<strong>RESULTS</strong><br>",
    "• <strong>Correlation:</strong> ", round(cor(tb$x, tb$y), digits = 4), "<br>",
    "• <strong>Slope (a):</strong> ", formatC(fit$coefficients[2], format = "e", digits = 3), "<br>",
    "• <strong>Intercept (b):</strong> ", formatC(fit$coefficients[1], format = "e", digits = 3), "<br>",
    "• <strong>SD (residuos):</strong> ", formatC(summary(fit)$sigma, format = "e", digits = 3), "<br>",
    "• <strong>R²:</strong> ", round(summary(fit)$r.squared, digits = 4)
  )

  # 2. Añadimos la parte condicional
  if(input$y_scale == "YeoJohnson"){
    texto_html <- paste0(
      texto_html, 
      "<br>• <strong>Lambda (YeoJohnson):</strong> ", formatC(lambda, format = "e", digits = 3)
    )
  }

  # 3. LO METEMOS TODO DENTRO DE TU CAJA CSS
  div(class = "box-metricas",
      HTML(texto_html)
  )
})
```

<!-- NUEVA COLUMNA CON UN DIAGRAMA DE DISPERSIÓN PARA COMPARAR LOS ATRIBUTOS TRANSFORMADOS--> 

Column
--------------------------------------------------

### Comparación atributos transformados

```{r grafica-compAtr} 
# Diagrama de dispersión de los indicadores seleccionados transformados
# Con la recta de regresión 
renderPlotly({
  
  # capturamos el resultado del procesado de los inputs 
  # y le añadimos una columna con la combinación municipio/Año 
  # para usarla en el desplegable
  tb <- inputs.processing.comparacion.atributos()[[1]] %>%
    mutate(`Región/Año`=paste(full_name," / ", year))
  
  # Cambiamos el nombre de los labels para que no sea código
    label_x <- if (input$ambito_ca == "Sectores laborales") {
      # En modo sectores, el input YA es el nombre (ej: "Construcción")
      input$x 
    } else {
      # En modo variables, buscamos el nombre en tu vector de opciones
      names(opciones_combinadas)[match(input$x, opciones_combinadas)]
    }
    
    # 2. Calculamos la etiqueta bonita para el Eje Y
    label_y <- if (input$ambito_ca == "Sectores laborales") {
      input$y
    } else {
      names(opciones_combinadas)[match(input$y, opciones_combinadas)]
    }

  # dibujamos el diagrama de dispersión 
  tb %>%
    ggplot(aes(x,y, label = `Región/Año`)) + 
    geom_point() +
    theme(legend.position = "none") +
    labs(x= label_x, y= label_y) +
    geom_smooth(method = lm, se = FALSE) 
  
})
```

<!-- NUEVA COLUMNA PARA IMPRIMIR LOS ATRIBUTOS TRANSFORMADOS--> 
<!-- 297 = 310 - barra scroll --> 

Column {data-width=297}
--------------------------------------------------

### Valores atributos transformados

```{r tabla-compAtr}
# imprimimos la tabla con los valores de los indicadores seleccionados 
# ordenados por el primer indicador
renderTable({
  
  # capturamos el resultado del procesado de los inputs 
  tb <- inputs.processing.comparacion.atributos()[[1]]
  
  # imprimimos la tabla 
  tb %>% 
  arrange(desc(x)) %>% 
  mutate(year=as.character(year)) %>% 
  rename(Región = full_name, Año = year) %>% 
  mutate(x=prettyNum(round(x,digits=2), big.mark = ",")) %>% 
  mutate(y=prettyNum(round(y,digits=2), big.mark = ","))
  
})
```


Predicción ARIMA
================
Column {.sidebar data-width=275}
--------------------------------------------------
```{r funcion-reactive-arima}
# --- CÁLCULO COMPARTIDO DEL MODELO ARIMA ---
calculo_modelo_arima <- reactive({
  
  # 1. Validamos inputs
  req(
    input$indicador_arima, input$unidad_arima, input$sector_arima,
    input$region_arima, input$year_arima
  )
  
  # 2. Preparamos los datos
  df_raw <- data %>%
    filter(
      item == input$indicador_arima,
      unit == input$unidad_arima,
      sector_name == input$sector_arima,
      geo == input$region_arima
    ) %>%
    select(year, values) %>%
    filter(!is.na(values))

  if (nrow(df_raw) == 0) {
    return(NULL) # Devuelve NULL si no hay datos válidos, para evitar el error momentaneo
  }
  
  # 3. Conversión a tsibble (Serie completa)
  ts_completa <- df_raw %>%
    distinct(year, .keep_all = TRUE) %>% 
    as_tsibble(index = year) %>%
    fill_gaps() 
  
  # 4. Filtro por año de inicio
  year_start <- input$year_arima
  if (length(year_start) == 0) return(NULL)
  
  datos_modelo <- ts_completa %>%
    filter(year >= year_start[1]) %>%
    filter(!is.na(values))
  
  if (nrow(datos_modelo) == 0) {
    return(NULL) # Devuelve NULL si después de filtrar por año no hay datos
  }
  
  # 5. Entrenamos el modelo
  arima_model <- datos_modelo %>%
    model(ARIMA(values)) 
  
  # --- DEVOLVEMOS UNA LISTA CON TODO LO NECESARIO ---
  return(list(
    modelo = arima_model,      # El objeto modelo entrenado
    datos_usados = datos_modelo, # Los datos recortados usados para el modelo
    serie_completa = ts_completa # La serie histórica completa (para pintar el contexto)
  ))
})
```

```{r widgets-arima}
# --- Selectores de parámetros ---
selectInput(
    "indicador_arima",
    label = "Indicador:",
    choices = indicadores_labels,
    selected = "Coste laboral medio / persona"
)

selectInput(
    "unidad_arima",
    label = "Unidad:",
    choices = unidad_labels,
    selected = "EUR"
)

selectInput(
    "sector_arima",
    label = "Sector:",
    choices = c("Total actividades", sort(setdiff(unique(data$sector_name), "Total actividades"))), # Total primero
    selected = "Total actividades"           
)


radioButtons(
  inputId = "nuts_arima",
  label = "NUTS:",
  choices = 0:2,
  selected = 0,
  inline = TRUE
)

selectInput(
    inputId = "region_arima",
    label = "Selecciona país:",
    choices = data %>% 
        filter(NUTS==0) %>% 
        pull(full_name) %>%
        unique() %>%
        sort(),
    selected = "Spain",
    
)

sliderInput(
    inputId = "year_arima",
    label = "Año de inicio datos:",
    min = 2000, # Valor temporal
    max = 2023, # Valor temporal
    value = 2000,
    step = 1,
    sep = "",
    ticks = FALSE
)

radioButtons(
   inputId = "h_arima", # 'h' es la letra típica para el horizonte de predicción
   label = "Años a predecir:",
   choices = 1:5,
   selected = 5, # Por defecto 5 años
   inline = TRUE
)

# --- Para que no se puedan seleccionar unidades que no existen ---
observe({
    req(input$indicador_arima) # Confirmamos que haya algo seleccionado
    
    # obtén el código del indicador seleccionado (por ejemplo "D1_SAL_HW")
    indicador_sel <- input$indicador_arima
    
    # busca las unidades válidas para ese indicador
    unidades_validas <- indicador_unidades[[indicador_sel]]
    
    # filtra tus etiquetas de unidades (para mostrar solo las disponibles)
    unidades_filtradas <- unidad_labels[unidad_labels %in% unidades_validas]
    
    # actualiza el selector de unidad con esas opciones
    updateSelectInput(
        inputId = "unidad_arima",
        choices = unidades_filtradas,
        selected = unidades_filtradas[1]
    )
})

# --- Para que no se puedan seleccionar sectores que no existen ---
observe({
    req(input$indicador_arima, input$unidad_arima) # Confirmamos que haya algo seleccionado
    
    # Filtramos los datos disponibles con los inputs actuales
    sectores_disponibles <- data %>%
        filter(
            item == input$indicador_arima,
            unit == input$unidad_arima
        ) %>%
        pull(sector_name) %>%
        unique() %>%
        sort()

    # Actualizamos las opciones del selector de sector
    updateSelectInput(
        inputId = "sector_arima",
        choices = c("Total actividades", sort(setdiff(unique(sectores_disponibles), "Total actividades"))),
        selected = "Total actividades"
      )
})

# --- Para seleccionar solo regiones disponibles ---
observe({
  # 1. Esperamos a que todos los filtros estén listos
  req(
    input$indicador_arima, 
    input$unidad_arima, 
    input$sector_arima, 
    input$nuts_arima
  )

  # 2. Definimos a quién queremos priorizar según el NUTS
  #    (Asegúrate de que el texto coincida con cómo viene en tus datos: "Spain" o "España")
  prioridad <- if (input$nuts_arima == "0") "Spain" else "Canarias"

  # 3. Filtramos y ORDENAMOS con la nueva lógica
  regiones_disponibles <- data %>%
    filter(
      item == input$indicador_arima,
      unit == input$unidad_arima,
      sector_name == input$sector_arima,
      NUTS == input$nuts_arima, 
      !is.na(values)
    ) %>%
    select(full_name, geo) %>%
    distinct() %>%
    # --- AQUÍ ESTÁ EL TRUCO ---
    # Creamos una columna temporal (TRUE si es el prioritario, FALSE si no)
    mutate(es_prioritario = grepl(prioridad, full_name, ignore.case = TRUE)) %>%
    # Ordenamos: Primero los TRUE (desc), luego alfabéticamente por nombre
    arrange(desc(es_prioritario), full_name) %>%
    # --------------------------
    select(full_name, geo) # Nos quedamos solo con lo que necesitamos
  
  # 4. Convertimos a vector nombrado
  choices_vector <- tibble::deframe(regiones_disponibles)
  
  # 5. Lógica de selección (se mantiene igual)
  seleccion_actual <- isolate(input$paises_arima)
  
  if (!is.null(seleccion_actual) && seleccion_actual %in% choices_vector) {
    nueva_seleccion <- seleccion_actual 
  } else {
    # Como hemos ordenado "Spain"/"Canarias" al principio, 
    # choices_vector[1] seleccionará automáticamente tu prioridad 
    # si la selección anterior no es válida.
    if (length(choices_vector) > 0) {
      nueva_seleccion <- choices_vector[1] 
    } else {
      nueva_seleccion <- NULL
    }
  }
  
  label_texto <- if (input$nuts_arima == "0") "Selecciona país:" else "Selecciona región:"

  # 6. Actualizamos
  updateSelectInput(
    session = session,
    inputId = "region_arima",
    label = label_texto,
    choices = choices_vector,
    selected = nueva_seleccion
  )
})

# --- Para actualizar el año inicial con los años disponibles ---
observe({
  # 1. Esperamos a tener el país/región seleccionado (y el resto de filtros)
  req(
    input$indicador_arima,
    input$unidad_arima,
    input$sector_arima,
    input$region_arima
  )

  # 2. Obtenemos los años disponibles para esa combinación exacta
  años_disponibles <- data %>%
    filter(
      item == input$indicador_arima,
      unit == input$unidad_arima,
      sector_name == input$sector_arima,
      # Aquí usamos el ID (geo) que devuelve el selectInput
      geo == input$region_arima, 
      !is.na(values)
    ) %>%
    pull(year) %>%
    unique()

  # 3. Calculamos min y max (con seguridad por si no hay datos)
  if (length(años_disponibles) > 0) {
    min_year <- min(años_disponibles)
    max_year <- max(años_disponibles)
  } else {
    # Valores por defecto de seguridad si falla la data
    min_year <- 2000 
    max_year <- 2023
  }

  # 4. Actualizamos el slider
  #    Importante: Actualizamos el 'range' (topes) y el 'value' (selección)
  updateSliderInput(
    session = session,
    inputId = "year_arima",
    min = min_year,
    max = max_year,
    value = min_year               # Reseteamos al inicio de los datos
  )
  
})
```

```{r metricas-arima}
# --- MÉTRICAS DEL MODELO (SIDEBAR) ---
renderUI({

# 1. Traemos el modelo
req(calculo_modelo_arima())
  resultado <- calculo_modelo_arima()
  req(resultado)
  
  # 2. Calculamos RMSE
  datos_con_residuos <- augment(resultado$modelo)
  rmse_val <- sqrt(mean(datos_con_residuos$.resid^2, na.rm = TRUE))
  
  # 3. Extraemos el nombre del modelo (ej: ARIMA(0,1,0))
  #    Cogemos la última columna del objeto mable que contiene el modelo
  columna_modelo <- length(resultado$modelo)
  nombre_modelo <- format(resultado$modelo[[columna_modelo]])
  
  # 4. Renderizamos (Estructura limpia)
  tagList(
    
    # Caja RMSE
    div(class = "box-metricas",
        h4("RMSE"),
        h2(prettyNum(round(rmse_val, 2), big.mark = ","))
    ),
    
    # Caja Modelo
    div(class = "box-metricas",
        h4("Modelo Seleccionado"),
        h3(nombre_modelo)
    )
  )      

})
```


<!-- Columna para las gráficas --> 

Column 
--------------------------------------------------

### 

```{r predicion-arima} 
renderPlotly({
  req(calculo_modelo_arima())
      # 1. Llamamos al reactive compartido
      #    Esto valida inputs y calcula el modelo (o recupera el cálculo si ya está hecho)
      resultado <- calculo_modelo_arima()
      
      # 2. Calculamos la predicción (Esto es rápido)
      req(input$h_arima)
      h_val <- as.numeric(input$h_arima)
      
      forecast_pred <- resultado$modelo %>%
        forecast(h = h_val)
      
      nombre_pais <- data %>%
      filter(geo == input$region_arima) %>%
      pull(full_name) %>% 
      unique() %>%
      head(1)
      
      # 3. Graficamos
      #    Usamos 'resultado$serie_completa' para que el gráfico muestre toda la historia
      GraficoDinamicoArima95CI(
        resultado$serie_completa,   
        "year",              
        "values",            
        forecast_pred,       
        "Predicción ARIMA"
      )
})
```

### 

```{r comparacion-arima} 
renderPlotly({
  req(calculo_modelo_arima())
    # 1. Llamamos al mismo reactive compartido
    resultado <- calculo_modelo_arima()
    
    # 2. Extraemos los valores ajustados (.fitted)
    datos_ajustados <- augment(resultado$modelo)
    
    nombre_pais <- data %>%
      filter(geo == input$region_arima) %>%
      pull(full_name) %>% 
      unique() %>%
      head(1)
    
    # 3. Graficamos con ggplot
    p <- ggplot(datos_ajustados, aes(x = year)) +
    geom_line(aes(y = values, color = "Real"), size = 0.8) +
    geom_line(aes(y = .fitted, color = "Ajuste ARIMA"), linetype = "dashed", size = 0.8) +
    labs(
      title = "            Ajuste del modelo",
      y = "Valor", x = "Año", color = NULL
    ) +
    scale_color_manual(values = c("Real" = "black", "Ajuste ARIMA" = "#d9534f"))
    p
})
```


Análisis de atributos
========================

```{r widgets-analisis-atributos}
# Widgets para selección de parámetros 
# En este caso la sintaxis es especial porque se usa código html para que aparezca en la misma
# línea el título del widget y la lista desplegable
div(
    style = "display: flex; align-items: center; gap: 30px;", # Misma línea, separación 30px
    # - Año -
    div(
        tagList(
          selectInput(
        "yearAtr", 
        label = "Año: ",
        choices = c("Media",2023:1995), # mean y todos los años descendente
        selected = "Media",
        ),
          helpText("\u00A0", 
                   style = "font-size: 11px; color: #666; margin-top: -10px;")
        )   
    ),    
    # - Indicador -
    div(
        tagList( # Usamos tagList para agrupar el input y el texto
          selectInput(
            "indicadorAtr",
            label = "Indicador:",
            choices = indicadores_labels[2],
            selected = "Coste laboral hora trabajada"
          ),
          helpText("Nota: Este es el único indicador con datos por sectores.", 
                   style = "font-size: 11px; color: #666; margin-top: -10px;")
        )
    ),
  
    # - Unidad -
    div(
        tagList(
        selectInput(
            "unidadAtr",
            label = "Unidad:",
            choices = unidad_labels[1:3],
            selected = "EUR"
        ),
        helpText("\u00A0", 
                   style = "font-size: 11px; color: #666; margin-top: -10px;")    
        )
    ),
    
    # - Países - CCAA -
    div(
        radioButtons(
            "pais_ccaa",
            label = "Ámbito: ",
            choices = c("Países", "CCAA"),
            selected = "Países"

        )
    )
)

observe({
  req(input$pais_ccaa)
  # 1. Definimos el rango según lo seleccionado
  rango_anos <- if (input$pais_ccaa == "Países") {
    2023 :1995
  } else {
    2023:2000
  }
  
  # 2. Actualizamos el selector de años
  updateSelectInput(session, "yearAtr",
    choices = c("Media", sort(rango_anos, decreasing = TRUE)),
    selected = "Media" # Reseteamos a Media para evitar errores de años no existentes
  )
  
})
```

```{r reactive-analisis-atributos}
# FUNCIÓN REACTIVE QUE FILTRA LOS DATOS EN FUNCIÓN DE input$yearAtr
# SI ES IGUAL A "mean" SE CALCULA LA MEDIA POR AÑOS. 
# SI ES IGUAL A UN AÑO SE TOMA EL ÚLTIMO VALOR DISPONIBLE IGUAL O
# MENOR QUE ESE AÑO. ADEMÁS SE PASAN LOS DATOS POR COLUMNAS
inputs.processing.analisis.atributos <- reactive( 

  if(input$yearAtr != "Media"){
    tb <- data %>%
      filter(year <= input$yearAtr, item==input$indicadorAtr, unit==input$unidadAtr, 
      (input$pais_ccaa == "Países" & NUTS == 0) | 
      (input$pais_ccaa == "CCAA" & substr(geo,1,2)=="ES" & NUTS==2)) %>%
      group_by(Región = full_name, sector_name) %>%
      summarise(values=last(values)) %>%
      ungroup() %>%
      pivot_wider(names_from = sector_name, values_from = values) %>%
      na.omit()
  
    return(tb)
    
  } else{
    tb <- data %>%
      filter(item==input$indicadorAtr, unit==input$unidadAtr, 
      (input$pais_ccaa == "Países" & NUTS == 0) | 
      (input$pais_ccaa == "CCAA" & substr(geo,1,2)=="ES" & NUTS==2))%>% 
      group_by(Región = full_name, sector_name) %>%
      summarise(values=mean(values)) %>%
      ungroup() %>%
      pivot_wider(names_from = sector_name, values_from = values) %>%
      na.omit()
    
    return(tb)
  }
)

```


Column {.tabset}
--------------------------------------------------

### Atrib. originales

```{r atribOrig-analisis-atributos}
shiny::renderTable({
  inputs.processing.analisis.atributos()
        
})
```

### Matriz correl.

```{r matriz-analisis-atributos}
# DIBUJAMOS LA MATRIZ DE CORRELACIÓN USANDO LA FUNCIÓN plot_correlation INCLUIDA EN "utilidades.R"
renderPlotly({
  inputs.processing.analisis.atributos() %>%
  select(-Región)  %>% 
  cor(use = "complete.obs") %>% 
  plot_correlation(show_values = TRUE) 
})
```


### Atrib. estandarizados 

```{r atribStand-analisis-atributos}
# IMPRIMIMOS LAS VARIABLES ESTANDARIZADAS (SE LE RESTA LA MEDIA Y 
# SE DIVIDE POR LA DESVIACIÓN TÍPICA) 
# PARA QUE FUNCIONE, TODOS LAS COLUMNAS DE LA TABLA DEBEN SER NUMÉRICAS Y 
# SIN NA. POR ELLO, PARA QUE LA COLUMNA Territorio CON EL NOMBRE DEL PAÍS 
# NO GENERE ERRORES TENEMOS QUE USAR LA FUNCIÓN column_to_rownames PARA
# QUE LA USE COMO TÍTULO DE LAS FILAS Y LAS DEJE FUERA DEL CÁLCULO 
shiny::renderTable({
  inputs.processing.analisis.atributos() %>% 
  column_to_rownames(var="Región") %>%
  scale() %>%
  as_tibble() %>% 
  mutate(Región=unique(inputs.processing.analisis.atributos()$Región)) %>%
  relocate(Región)
})

```


### PCs

```{r pca-analisis-atributos}
# CALCULAMOS COMPONENTES PRINCIPALES CON LA FUNCIÓN prcomp
# PARA QUE FUNCIONE, TODOS LAS COLUMNAS DE LA TABLA DEBEN SER NUMÉRICAS Y 
# SIN NA. POR ELLO, PARA QUE LA COLUMNA Territorio CON EL NOMBRE DEL PAÍS 
# NO GENERE ERRORES TENEMOS QUE USAR LA FUNCIÓN column_to_rownames PARA
# QUE LA USE COMO TÍTULO DE LAS FILAS Y LAS DEJE FUERA DEL CÁLCULO DE LAS PC

pca <- reactive(
  return(
    inputs.processing.analisis.atributos() %>%
    column_to_rownames(var="Región") %>% 
    prcomp(scale = TRUE)  
  )
)
```


```{r pcs-analisis-atributos}
# IMPRIMIMOS LAS COMPONENTES PRINCIPALES. COMO LOS NOMBRES DE LOS PAÍSES
# NO SE HAN GUARDADO AL CALCULAR pca LOS VOLVEMOS A AÑADIR 
shiny::renderTable({
  pca()$x %>% as_tibble()  %>% 
  mutate(Región=unique(inputs.processing.analisis.atributos()$Región)) %>%
  relocate(Región)
})

```


### Pesos combinación lineal PCs

```{r pesos-analisis-atributos}
# IMPRIMIMOS LOS PESOS (COEFICIENTES) USADOS PARA CALCULAR LOS PC
# A PARTIR DE LAS VARIABLES ORIGINALES. 
shiny::renderTable({
  as_tibble(pca()$rotation, rownames = "Sector laboral")
})
```


### Varianza explicada

```{r varianza-analisis-atributos} 
# DIAGRAMA DE BARRAS CON LA VARIANZA EXPLICADA
# EL Nº DE PC SE PUEDE OBTENER HACIENDO length(pca$sdev)
renderPlotly({
  pca <- pca()
 tibble(
  label=fct_inorder(paste("PC",1:length(pca$sdev))),
  varPercent = pca$sdev^2/sum(pca$sdev^2) * 100
) %>%
  ggplot(aes(x=label,y=varPercent)) +
    geom_bar(stat = "identity") +
    labs(x= "Componentes Principales", 
          y= "Porcentaje varianza explicada"
    )+
   geom_text(aes(label=paste0(round(varPercent,digits = 1),"%")), 
                 size=3,
                 colour = "blue",
                 nudge_y = 1.
             ) 
  
})
```


### Visualización PCs

```{r visualizacion-analisis-atributos} 
tags$style(HTML("
  #PCx, #PCy {
    height: 30px !important;
    min-height: 30px !important;
    font-size: 12px !important;
    padding-top: 5px !important;    
    padding-bottom: 5px !important;
    line-height: 1.5 !important;
    padding-left: 10px !important;
    padding-right: 5px !important
  }

 
  #contenedor_grafico_absoluto {
    position: absolute;
    top: 60px;
    left: 0;
    right: 0;
    bottom: 0;
    overflow: hidden;
  }
"))



tags$div(
  style = "height: 50px; display:flex; gap:20px; align-items:center; flex-wrap:wrap; margin-bottom: 10px;",
 
  tags$div(
    style ="display:flex; align-items:center; gap:6px; min-width:150px;",
    tags$label("Eje X:", style = "margin-bottom:0; white-space:nowrap; font-weight:bold;"),
    numericInput(
      "PCx", label = NULL, value = 1, min = 1, max = 15, step = 1, width = "50px"
    )
  ),
 
  tags$div(
    style = "display:flex; align-items:center; gap:6px; min-width:150px;",
    tags$label("Eje Y:", style = "margin-bottom:0; white-space:nowrap; font-weight:bold;"),
    shiny::numericInput(
      "PCy", label = NULL, value = 2, min = 1, max = 15, step = 1, width = "50px"
    )
  )
)

tags$div(
  id = "contenedor_grafico_absoluto",
  highcharter::highchartOutput("grafico_pca_out", height = "100%")
)


output$grafico_pca_out <- highcharter::renderHighchart({
  hchart(pca(), choices = c(input$PCx, input$PCy))
})
```


Series temporales
=================

Column {.sidebar data-width=275}
--------------------------------------------------

```{r}
radioButtons(
    "ambito_series",
    label = "Comparar por: ",
    choices = c("Regiones", "Sectores laborales"),
    selected = "Regiones"
)

# - Indicador -
selectInput(
    "indicador_series",
    label = "Indicador:",
    choices = indicadores_labels,
    selected = "Coste laboral medio / persona"
)
  
# - Unidad -
selectInput(
    "unidad_series",
    label = "Unidad:",
    choices = unidad_labels,
    selected = "EUR"
)

# - NUTS -
radioButtons(
    "nuts_series",
    label = "NUTS:",
    choices = c(0:2, "CCAA"),
    selected = 0,
    inline = TRUE
)

# opciones_series <- data %>%
#     filter(NUTS == 0) %>%
#     select(full_name, geo) %>% 
#     distinct() %>%
#     arrange(full_name) %>%
#     tibble::deframe()
# 
# selectInput(
#     inputId = "seleccion_series",
#     label = "Selecciona país:",
#     choices = opciones_mapa,
    # selected = "Spain",      # <-- Perfecto, empieza vacío
# )

renderUI({
  # Dependemos de que los datos ya estén calculados para saber cuántas páginas hay
  req(filtrado_series_temporales())
  total_pags <- filtrado_series_temporales()$total_paginas
  actual_page <- filtrado_series_temporales()$pag_actual
  
  # Si solo hay 1 página, no mostramos el selector para no ensuciar
  # if (total_pags <= 1) return(NULL)
  
  # Input numérico simple con flechitas
  numericInput(
    inputId = "pagina_series",
    label = paste0("Página (", actual_page, " de ", total_pags, "):"),
    value = actual_page,
    min = 1,
    max = total_pags,
    step = 1
  )
})

# --- Para que no se puedan seleccionar unidades que no existen ---
observe({
    req(input$indicador_series) # Confirmamos que haya algo seleccionado
    
    # obtén el código del indicador seleccionado (por ejemplo "D1_SAL_HW")
    indicador_sel <- input$indicador_series
    
    # busca las unidades válidas para ese indicador
    unidades_validas <- indicador_unidades[[indicador_sel]]
    
    # filtra tus etiquetas de unidades (para mostrar solo las disponibles)
    unidades_filtradas <- unidad_labels[unidad_labels %in% unidades_validas]
    
    # actualiza el selector de unidad con esas opciones
    updateSelectInput(
        inputId = "unidad_series",
        choices = unidades_filtradas,
        selected = unidades_filtradas[1]
    )
})

# --- Solo el indicador disponible si comparamos por sectores ---
observe({
  req(input$ambito_series)
  
  if (input$ambito_series == "Sectores laborales") {
    
    # 1. Forzamos el indicador a Coste Laboral / Persona
    updateSelectInput(
      inputId = "indicador_series",
      selected = "Coste laboral medio / persona" 
    )
  }
})
```


```{r funcion-series2}
filtrado_series_temporales <- reactive({
  
  # 1. Validaciones básicas
  req(
    input$indicador_series, 
    input$unidad_series, 
    input$nuts_series
  )
  
  # --- MODIFICACIÓN 1: Definimos los códigos que quieres fijos ---
  codigos_fijos <- c("ES", "ES70") 

  # 2. Filtro Base (Tus datos variables según el NUTS seleccionado)
  df_base <- data %>%
    filter(
      item == input$indicador_series,
      unit == input$unidad_series,
      NUTS == input$nuts_series,
      !is.na(values)
    )
  
  # --- MODIFICACIÓN 2: Rescatamos datos de España y Canarias SIEMPRE (Ignorando el NUTS) ---
  df_fijos <- data %>%
    filter(
      item == input$indicador_series,
      unit == input$unidad_series,
      geo %in% codigos_fijos,
      !is.na(values)
    )

  # Si no hay datos en ninguno de los dos lados, paramos
  if(nrow(df_base) == 0 && nrow(df_fijos) == 0) return(NULL)

  # --- RAMA A: COMPARAR PAÍSES (PAGINACIÓN) ---
  if (input$ambito_series == "Regiones") { 
    
    # a. Obtenemos la lista única de territorios VARIABLES (Quitamos los fijos para no duplicar)
    #    Esto es importante: si seleccionas NUTS 0, España ya estaría en df_base, hay que quitarla de ahí
    #    para gestionarla nosotros.
    
    # Filtramos a un solo sector
    df_base <- filter(df_base, sector_name == "Total actividades")
    df_fijos <- filter(df_fijos, sector_name == "Total actividades")
    
    lista_geo <- df_base %>% 
      filter(!geo %in% codigos_fijos) %>%
      pull(full_name) %>%
      unique()
      
    n_total   <- length(lista_geo)
    
    # b. Calculamos el total de páginas (10 variables + 2 fijos = 12 huecos)
    plots_por_pagina <- 10  # <--- CAMBIADO A 10 para dejar hueco a los 2 fijos
    
    # Si no hay variables, al menos 1 página para mostrar los fijos
    total_paginas <- if(n_total == 0) 1 else ceiling(n_total / plots_por_pagina)
    
    # c. Detectamos la página actual
    pag_actual <- if (is.null(input$pagina_series)) 1 else as.numeric(input$pagina_series)
    if (pag_actual > total_paginas) pag_actual <- 1 # Reset seguridad
    
    # d. Matemática de recorte (Slicing) SOLO de los variables
    geo_seleccionados <- character(0)
    
    if (n_total > 0) {
      indice_inicio <- (pag_actual - 1) * plots_por_pagina + 1
      indice_fin    <- min(indice_inicio + plots_por_pagina - 1, n_total)
      geo_seleccionados <- lista_geo[indice_inicio:indice_fin]
    }
    
    # e. Filtramos el dataframe de variables
    df_variable_pag <- df_base %>%
      filter(full_name %in% geo_seleccionados)
    
    # --- MODIFICACIÓN 3: UNIÓN FINAL ---
    # Pegamos los Fijos + Los Variables de esta página
    df_final <- bind_rows(df_fijos, df_variable_pag)
    
    # (Opcional) Forzamos el orden para que salgan primero en el gráfico
    orden_visual <- unique(c(unique(df_fijos$full_name), geo_seleccionados))
    df_final$full_name <- factor(df_final$full_name, levels = orden_visual)
    
    return(list(
      datos = df_final, 
      total_paginas = total_paginas,
      pag_actual = pag_actual
    ))
  } 
  
  # --- RAMA B: COMPARAR SECTORES ---
  else {
    return(list(
      datos = df_base,
      total_paginas = 1,
      pag_actual = 1
    ))
  }
})
```


```{verbatim funcion-series}
filtrado_series_temporales <- reactive({
  
  # 1. Validaciones básicas
  req(
    input$indicador_series, 
    input$unidad_series, 
    input$nuts_series
  )

  # 2. Filtro Base (Común a ambos modos)
  df_base <- data %>%
    filter(
      item == input$indicador_series,
      unit == input$unidad_series,
      NUTS == input$nuts_series,
      !is.na(values)
    )
  
  # Si no hay datos, paramos
  if(nrow(df_base) == 0) return(NULL)

  # --- RAMA A: COMPARAR PAÍSES (PAGINACIÓN) ---
  if (input$ambito_series == "Regiones") {
    
    # a. Obtenemos la lista única de territorios disponibles
    lista_geo <- unique(df_base$full_name)
    n_total   <- length(lista_geo)
    
    # b. Calculamos el total de páginas (12 por página)
    plots_por_pagina <- 12
    total_paginas    <- ceiling(n_total / plots_por_pagina)
    
    # c. Detectamos la página actual (con seguridad por si es NULL al inicio)
    # pag_actual <- if (is.null(input$pagina_series)) 1 else as.numeric(input$pagina_series)
    pag_actual <- if (is.null(input$pagina_series)) 1 else as.numeric(input$pagina_series)
    
    # Validación extra: si cambias de filtro y la página 5 ya no existe, volvemos a la 1
    # if (pag_actual > total_paginas) pag_actual <- 1
    
    # d. Matemática de recorte (Slicing)
    indice_inicio <- (pag_actual - 1) * plots_por_pagina + 1
    indice_fin    <- min(indice_inicio + plots_por_pagina - 1, n_total)
    
    # e. Seleccionamos LOS NOMBRES de esta página
    geo_seleccionados <- lista_geo[indice_inicio:indice_fin]
    
    # f. Filtramos el dataframe final
    df_final <- df_base %>%
      filter(full_name %in% geo_seleccionados) %>% 
      filter(sector_name == "Total actividades") 
      # Nota: Aquí solemos filtrar también por "Total actividades" si comparamos países
    
    return(list(
      datos = df_final, 
      total_paginas = total_paginas,
      pag_actual = pag_actual
    ))
  } 
  
  # --- RAMA B: COMPARAR SECTORES ---
  else {
    # En modo sectores, normalmente queremos ver todos los sectores
    # pero quizás de UN solo país (o el usuario seleccionará abajo).
    # Como no has puesto selector de país en este snippet, asumo que 
    # quieres devolver todo y ya filtrarás en el gráfico o se mostrará todo.
    
    return(list(
      datos = df_base,
      total_paginas = 1, # En sectores no paginamos (o paginamos distinto)
      pag_actual = 1
    ))
  }
})
```

Column {.tabset}
--------------------------------------------------
### Separados

```{r}
renderPlotly({
  tb <- filtrado_series_temporales()$datos
    
  if (input$ambito_series == "Regiones") {
      
  tb %>% 
    mutate(full_name = factor(full_name,  # Poner Canarias y España primero
                       levels = c("Canarias", "Spain",
                                  setdiff(unique(full_name), c("Canarias", "Spain"))))) %>%
    ggplot(aes(year,y=values)) +
    geom_line() +
    facet_wrap(~full_name,scales = "free_y",ncol=4) +
    theme(axis.text.x = element_text(angle = 45,hjust=1)) + 
    labs(x="",y="")
      
  } else {
    ggplot(aes(year,y=values)) +
    geom_line() +
    facet_wrap(~sector_name,scales = "free_y",ncol=4) +
    theme(axis.text.x = element_text(angle = 45,hjust=1)) + 
    labs(x="",y="")
      
  }
})
```






### Superpuestos



















