---
title: "Dashboard - Datos Laborales"
author: "Alejandro Delgado Valera"
output: flexdashboard::flex_dashboard
runtime: shiny
---

```{r global, include=FALSE}
library(pxR)
library(MASS)
library(shinydashboard)
library(datasets)
library(highcharter) 
library(fpp3)
library(RColorBrewer)
library(openxlsx)  
library(leaflet)  
library(geojsonio)
library(plotly)
library(ggplot2)
library(tidyverse)
library(shinyWidgets)
pdf(file = NULL) # evita errores en shiny 

# asociamos funciones a determinadas librerías para evitar posibles errores 
filter <- dplyr::filter # Filtra filas según condiciones
select <- dplyr::select # Selecciona columnas
mutate <- dplyr::mutate # Crea o modifica columnas
arrange <- dplyr::arrange # Ordena filas
group_by <- dplyr::group_by # Agrupa datos
summarise <- dplyr::summarise # Resume variables (por ejemplo, con medias, conteos)
summarize <- dplyr::summarize # Lo mismo que summarise
rename <- dplyr::rename # Cambia nombres de columnas
distinct <- dplyr::distinct # Elimina filas duplicadas
slice<- dplyr::slice # Selecciona filas por posición
relocate<- dplyr::relocate # Reordena columnas

selectInput <- shiny::selectInput

# Colocamos las funciones en este mismo fichero para evitar dependencias ####

# Función de Pareto
# Dado un vector de números y un nivel de significancia de Pareto, calcula el valor del vector tal que la suma de los valores por encima de ese valor supera el total de la suma multiplicado por el nivel de significancia.

ParetoValue <- function(
        v, # vector numérico
        ParetoSignificancia # número en [0,1] con el grado de significancia de Pareto
){
    
    x <- sort(v,decreasing = TRUE)
    return(x[which(cumsum(x)>=ParetoSignificancia*sum(x))[1]])
}


#FUNCIÓN PARA DIBUJAR UNA PREDICCIÓN DINÁMICA CON USANDO plotly
GraficoDinamicoArima95CI <- function(
 data, # tssible con con los datos originales
 date, # string con el nombre se la variable temporal en data
 value, # string con el nombre se la variable numérica en data
 prediccion, # objeto con la predicción usando ARIMA u otro modelo
 TITLE # título del gráfico 
){
  
  fc <- prediccion %>%
  mutate(lower = NA) %>% 
  mutate(upper = NA) 

  for(k in 1:nrow(fc)){
    fc$lower[k] <- fc$.mean[k] - 1.96*unlist(fc[[value]][k])[2]
    fc$upper[k] <- fc$.mean[k] + 1.96*unlist(fc[[value]][k])[2]
  }
  
  data2 <- data 
  x <- data2[[date]][1]
  if(!(is.numeric(x) && !inherits(x, "Date") && !inherits(x, "POSIXt"))){
    data2[[date]] <- as.Date(data2[[date]])
    fc[[date]] <- as.Date(fc[[date]])
  }
  


p <- plot_ly() %>%
  add_lines(x=data2[[date]], y = data2[[value]], name = "Observación", line = list(color = "black")) %>%
  add_lines(x=fc[[date]], y = fc$.mean, name = "Predicción", line = list(color = "blue")) %>%
  add_ribbons(x = fc[[date]], ymin = fc$lower, ymax = fc$upper, 
              name = "95% CI", fillcolor = "rgba(0,0,150,0.2)", line = list(width = 0)) %>%
  layout(title = TITLE)

return(p) 
}
  

#FUNCIÓN PARA DIBUJAR UN MAPA COROPLÉTICO USANDO leaflet
MapaCoroplético <- function(
 geoj, # objeto gráfico geojson con los contornos de las regiones
 value, # vector de valores para colorear 
 region_labels, # vector de etiquetas para los desplegables
 legend_title # título de la leyenda 
){

vals <- value[!is.na(value)]
breaks <- unique(pretty(vals))

pal <- colorBin(
  palette = "YlOrRd",
  domain  = vals,
  bins    = breaks
)

p <-  geoj %>%
    leaflet() %>%  
    setView(lng = 10, lat = 48, zoom = 4)  %>% 
    addPolygons(
        fillColor = ~pal(value),
        weight = 1,
        opacity = 1,
        color = "#555555",
        dashArray = "",
        fillOpacity = 0.75,
        highlightOptions = highlightOptions(
            weight = 3,
            color = "#333333",
            dashArray = "",
            fillOpacity = 0.8,
            bringToFront = TRUE
        ),
      label = region_labels 
    ) %>% 
    addLegend("bottomleft", 
      pal = pal, 
      values = value,
      title = legend_title,
      labFormat = function(type, cuts, p) {
        n = length(cuts) 
        x = (cuts[-n] + cuts[-1])/2
        x=prettyNum(round(x,
            digits=max(5-nchar(as.character(round(max(na.omit(value))))),0)), 
            big.mark = ","
        )
        as.character(x)
      },
      opacity = 1
    )
  return(p)
}



# CÁLCULO DE LA TRANSFORMACIÓN DE YEO–JOHNSON A PARTIR DE UN VECTOR Y UN VALOR DE lambda 
yeo.johnson <- function(y, lambda) {
  y_t <- numeric(length(y))
  
  # Para y >= 0
  pos_idx <- which(y >= 0)
  if (lambda == 0) {
    y_t[pos_idx] <- log(y[pos_idx] + 1)
  } else {
    y_t[pos_idx] <- ((y[pos_idx] + 1)^lambda - 1) / lambda
  }
  
  # Para y < 0
  neg_idx <- which(y < 0)
  if (lambda == 2) {
    y_t[neg_idx] <- -log(-y[neg_idx] + 1)
  } else {
    y_t[neg_idx] <- -(((-y[neg_idx] + 1)^(2 - lambda) - 1) / (2 - lambda))
  }
  
  return(y_t)
}


# ESTIMACIÓN DE lambda PARA LA TRANSFORMACIÓN DE YEO–JOHNSON DE UN VECTOR y
# OPTIMIZANDO  EL R2 DE LA REGRESIÓN LINEAL CON UN VECTOR x.  
optimize.yeojohnson.R2 <- function(x, y, lambda_range = c(-1, 1.9)) {
 
  # Función objetivo: R² negativo (porque optimize minimiza)
  r2_neg <- function(lambda) {
    y_t <- yeo.johnson(y, lambda)
    modelo <- lm(y_t ~ x)
    return(-summary(modelo)$r.squared)  # queremos maximizar R²
  }
  
  # Optimización de lambda
  opt <- optimize(r2_neg, interval = lambda_range)
  
  # Se retorna el valor óptimo de lambda 
  return(opt$minimum)
}

```

<!-- Carga inicial de los datos -->
```{r analisis-data-raw, results=F}
data_raw <- read_csv('data/nama_10r_2lp10.csv') %>% 
    as_tibble()

data_raw
```
```{r analisis-inicial, results=F}
real_names <- read_csv('data/eurostac_real_nuts.csv') %>% 
    as_tibble()


data <- data_raw %>% 
    select(-freq) %>% 
    rename(year = TIME_PERIOD, sector = nace_r2, item = na_item) %>% 
    left_join(real_names, by='geo') %>% 
    select(geo, NUTS, full_name, year, sector, item, unit, values) %>% 
    mutate(sector_name = case_when(
        sector == "TOTAL" ~ "Total actividades",
        sector == "O-U" ~ "Adm. pública, educación y salud",
        sector == "O-Q" ~ "Adm. pública, defensa y educación",
        sector == "B-E" ~ "Industria",
        sector == "K-N" ~ "Finanzas e inmobiliarias",
        sector == "F" ~ "Construcción",
        sector == "M_N" ~ "Profesionales y científicas",
        sector == "A" ~ "Agricultura y pesca",
        sector == "C" ~ "Manufactura",
        sector == "G-J" ~ "Comercio y transporte",
        sector == "R-U" ~ "Artes y otros servicios",
        sector == "G-I" ~ "Comercio y alojamiento",
        sector == "J" ~ "Información y comunicación",
        sector == "K" ~ "Finanzas",
        sector == "L" ~ "Inmobiliarias",
        TRUE ~ "Otro"
        )) %>% 
    relocate(sector_name, .after=sector)
    

data
```
```{r archivos-geoj, results=F}
geoj0 <- geojson_read("https://gisco-services.ec.europa.eu/distribution/v2/nuts/geojson/NUTS_RG_20M_2024_4326_LEVL_0.geojson",  what = "sp")
geoj0.tb <- geoj0 %>%
  as_tibble() 
geoj1 <- geojson_read("https://gisco-services.ec.europa.eu/distribution/v2/nuts/geojson/NUTS_RG_20M_2024_4326_LEVL_1.geojson",  what = "sp")
geoj1.tb <- geoj1 %>%
  as_tibble() 
geoj2 <- geojson_read("https://gisco-services.ec.europa.eu/distribution/v2/nuts/geojson/NUTS_RG_20M_2024_4326_LEVL_2.geojson",  what = "sp")
geoj2.tb <- geoj2 %>%
  as_tibble() 
```


Series temporales (por países)
=================
```{r ST_paises-analisis-data}
filtrado_series_temporales <- reactive({
    tb <- data %>% 
        filter(item == input$indicador, unit == input$unidad, sector_name == input$sector)
    return(tb)
})
```

```{r ST_paises-widgets-seleccion}
# --- Relación entre indicadores (códigos del dataset) y las unidades disponibles ---
indicador_unidades <- list(
    "D1_SAL_PER" = c("EUR", "NAC", "PC_EU27_2020_MEUR_CP"),
    "D1_SAL_HW"  = c("EUR", "NAC", "PC_EU27_2020_MEUR_CP"),
    "HW_EMP"     = c("HW", "PCH_PRE")
)

# --- Nombres descriptivos para mostrar en el selector ---
indicadores_labels <- c(
    "Coste laboral medio / persona" = "D1_SAL_PER",
    "Coste laboral / hora trabajada" = "D1_SAL_HW",
    "Horas trabajadas en promedio" = "HW_EMP"
)

unidad_labels <- c(
    "EUR" = "EUR",
    "Moneda nacional" = "NAC",
    "Porcentaje UE27" = "PC_EU27_2020_MEUR_CP",
    "Var. porcentual" = "PCH_PRE",
    "Horas anuales" = "HW"
)

# --- Selectores de parámetros ---
div(
    style = "display: flex; align-items: center; gap: 30px;", # Misma línea, separación 30px
  
    # - Indicador -
    div(
        selectInput(
            "indicador",
            label = "Indicador:",
            choices = indicadores_labels,
            selected = "Coste laboral medio / persona"
        )
    ),
  
    # - Unidad -
    div(
        selectInput(
            "unidad",
            label = "Unidad:",
            choices = unidad_labels,
            selected = "EUR"
        )
    ),
  
   # - Sector -
    div(
        selectInput(
            inputId = "sector",
            label = "Sector:",
            choices = c("Total actividades", sort(setdiff(unique(data$sector_name), "Total actividades"))),
            selected = "Total actividades"           
        )
    ),
  
    # Condicional para la comparativa de países
    conditionalPanel(
        # La 'condition' es una expresión de JavaScript.
        condition = "input.ID_DE_TUS_PESTAÑAS == 'Comparativa países'",
    
        div( # Lo envuelvo en un div para que sea un "hijo" del flexbox
            selectInput(
                inputId = "paises_seleccion",
                label = "Selecciona países:",
                choices = data %>% 
                    filter(NUTS==0) %>% 
                    pull(full_name) %>%
                    unique() %>%
                    sort(),
            multiple = TRUE,
            selected = "Spain"
            )
        )
    ),
  
    # Condicional para la comparativa de CCAA
    conditionalPanel(
        # La 'condition' es una expresión de JavaScript.
        condition = "input.ID_DE_TUS_PESTAÑAS == 'Comparativa CCAA'",
    
        div( # Lo envuelvo en un div para que sea un "hijo" del flexbox
            selectInput(
                inputId = "ccaa_seleccion",
                label = "Selecciona comunidades:",
                choices = data %>% 
                    filter((substr(geo, 1, 2) == "ES" & NUTS == 2)) %>% 
                    pull(full_name) %>%
                    unique() %>%
                    sort(),
            multiple = TRUE,
            selected = "Canarias"
            )
        )
    )
)


# --- Para que no se puedan seleccionar unidades que no existen ---
observe({
    req(input$indicador) # Confirmamos que haya algo seleccionado
    
    # obtén el código del indicador seleccionado (por ejemplo "D1_SAL_HW")
    indicador_sel <- input$indicador
    
    # busca las unidades válidas para ese indicador
    unidades_validas <- indicador_unidades[[indicador_sel]]
    
    # filtra tus etiquetas de unidades (para mostrar solo las disponibles)
    unidades_filtradas <- unidad_labels[unidad_labels %in% unidades_validas]
    
    # actualiza el selector de unidad con esas opciones
    updateSelectInput(
        inputId = "unidad",
        choices = unidades_filtradas,
        selected = unidades_filtradas[1]
    )
})

# --- Para que no se puedan seleccionar sectores que no existen ---
observe({
    req(input$indicador, input$unidad) # Confirmamos que haya algo seleccionado
    
    # Filtramos los datos disponibles con los inputs actuales
    sectores_disponibles <- data %>%
        filter(
            item == input$indicador,
            unit == input$unidad
        ) %>%
        pull(sector_name) %>%
        unique() %>%
        sort()

    # Actualizamos las opciones del selector de sector
    updateSelectInput(
        inputId = "sector",
        choices = c("Total actividades", sort(setdiff(unique(sectores_disponibles), "Total actividades"))),
        selected = "Total actividades"
      )
})
```


Column {.tabset}
--------------------------------------------------
```{r ST_paises-agrupaciones-paises}
# España y Canarias
referencia <- c("ES", "ES7")

paises_principales <- c(
  referencia,
  "DE", # Alemania
  "FR", # Francia
  "IT", # Italia
  "NL", # Países Bajos
  "BE", # Bélgica
  "SE", # Suecia
  "PL", # Polonia
  "AT", # Austria
  "DK", # Dinamarca
  "IE", # Irlanda
  "PT", # Portugal
  "CZ", # Chequia
  "HU", # Hungría
  "LU"  # Luxemburgo
)

paises_resto <- c(
  referencia,
  "BG", # Bulgaria
  "HR", # Croacia
  "CY", # Chipre
  "EE", # Estonia
  "EL", # Grecia
  "LT", # Lituania
  "LV", # Letonia
  "FI", # Finlandia
  "MT", # Malta
  "SI", # Eslovenia
  "RO", # Rumanía
  "SK", # Eslovaquia
  "RS", # Serbia
  "MK"  # Macedonia del Norte
)
```

### Países 1
```{r ST_paises-paises1}
# Países 1
renderPlotly({
  tb <- filtrado_series_temporales()
    
  tb %>% 
    filter(geo %in% paises_principales) %>%
    mutate(full_name = factor(full_name,  # Poner Canarias y España primero
                       levels = c("Canarias", "Spain",
                                  setdiff(unique(full_name), c("Canarias", "Spain"))))) %>%
    ggplot(aes(year,y=values)) +
    geom_line() +
    facet_wrap(~full_name,scales = "free_y",ncol=4) +
    theme(axis.text.x = element_text(angle = 45,hjust=1)) + 
    labs(x="",y="")
})
```

### Países 2
```{r ST_paises-paises2}
# Países 2
renderPlotly({
  tb <- filtrado_series_temporales()
    
  tb %>% 
    filter(geo %in% paises_resto) %>%
    mutate(full_name = factor(full_name,  # Poner Canarias y España primero
                       levels = c("Canarias", "Spain",
                                  setdiff(unique(full_name), c("Canarias", "Spain"))))) %>%
    ggplot(aes(year,y=values)) +
    geom_line()+
    facet_wrap(~full_name,scales = "free_y",ncol=4) +
    theme(axis.text.x = element_text(angle = 45,hjust=1)) + 
    labs(x="",y="")
})
```

### CCAA
```{r ST_paises-ccaa}
renderPlotly({
  tb <- filtrado_series_temporales()
    
  tb %>% 
    filter((substr(geo, 1, 2) == "ES" & NUTS == 2) | geo == "ES") %>%
    mutate(full_name = factor(full_name, # Poner Canarias y España primero
                       levels = c("Canarias", "Spain",
                                  setdiff(unique(full_name), c("Canarias", "Spain"))))) %>%
    ggplot(aes(year, y = values)) +
    geom_line() +
    facet_wrap(~full_name, scales = "free_y", ncol = 4) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(x = "", y = "")
})
```

### Comparativa países
```{r ST_paises-input-comparativa-paises}
selectInput(
        inputId = "paises_seleccion",
        label = "Selecciona países:",
        choices = data %>% 
            filter(NUTS==0) %>% 
            pull(full_name) %>%
            unique() %>%
            sort(),
        multiple = TRUE,
        selected = "Spain"
      )
```

```{r ST_paises-comparativa-paises}
div(renderHighchart({
      req(input$paises_seleccion, input$indicador, input$unidad) # Validar que los inputs no estén vacíos
      
    # 1. Datos de las CCAA (del input)
      data_paises <- filtrado_series_temporales() %>%
        filter(
          full_name %in% input$paises_seleccion,
          item == input$indicador,
          unit == input$unidad
        ) %>%
        arrange(year)
        
      # 2. Datos de EU27 (siempre)
      data_eu <- filtrado_series_temporales() %>%
        filter(
          geo == "EU27_2020", 
          item == input$indicador,
          unit == input$unidad
        ) %>%
        arrange(year)
    
      # 3. Gráfico base (con CCAA) y añadir serie de España
      hchart(
        data_paises, # Gráfico base con las CCAA seleccionadas
        type = "line",
        hcaes(x = year, y = values, group = full_name),
        marker = list(enabled = TRUE)
      ) %>%
      
        hc_add_series(
          data = data_eu,          
          type = "line",
          hcaes(x = year, y = values),
          name = "Media UE (Referencia)",
          dashStyle = "Dash",   
          color = "lightgrey",  
          marker = list(enabled = FALSE) 
        ) %>%
        hc_title(text = "") %>%
        hc_xAxis(title = list(text = NULL)) %>%
        hc_yAxis(title = list(text = NULL)) %>%
        hc_legend(enabled = TRUE) %>% 
        hc_chart(height = 500)
    })
)

```

### Comparativa CCAA
```{r ST_paises-input-comparativa-ccaa}
# Selector de comunidades
selectInput(
        inputId = "ccaa_seleccion",
        label = "Selecciona comunidades:",
        choices = data %>% 
            filter((substr(geo, 1, 2) == "ES" & NUTS == 2)) %>% 
            pull(full_name) %>%
            unique() %>%
            sort(),
        multiple = TRUE,
        selected = "Canarias"
      )
```

```{r ST_paises-comparativa-ccaa}
div(renderHighchart({
      req(input$ccaa_seleccion, input$indicador, input$unidad) # Validar que los inputs no estén vacíos
      
    # 1. Datos de las CCAA (del input)
      data_ccaa <- filtrado_series_temporales() %>%
        filter(
          full_name %in% input$ccaa_seleccion, # Asumimos que "Spain" no viene aquí
          item == input$indicador,
          unit == input$unidad
        ) %>%
        arrange(year)
        
      # 2. Datos de España (siempre)
      data_espana <- filtrado_series_temporales() %>%
        filter(
          full_name == "Spain", 
          item == input$indicador,
          unit == input$unidad
        ) %>%
        arrange(year)
    
      # 3. Gráfico base (con CCAA) y añadir serie de España
      hchart(
        data_ccaa, # Gráfico base con las CCAA seleccionadas
        type = "line",
        hcaes(x = year, y = values, group = full_name),
        marker = list(enabled = TRUE)
      ) %>%
      
        hc_add_series(
          data = data_espana,          
          type = "line",
          hcaes(x = year, y = values),
          name = "España (Referencia)",
          dashStyle = "Dash",   
          color = "lightgrey",  
          marker = list(enabled = FALSE) 
        ) %>%
        hc_title(text = "") %>%
        hc_xAxis(title = list(text = NULL)) %>%
        hc_yAxis(title = list(text = NULL)) %>%
        hc_legend(enabled = TRUE) %>% 
        hc_chart(height = 500)
    })
)
```


Mapa coroplético
================

Column {.sidebar data-width=270}
--------------------------------------------------

```{r}
# Widgets para selección de parámetros 
pickerInput(
    "indicador_mapa",
    label = "Indicador:",
    choices = indicadores_labels,
    selected = "Coste laboral medio / persona"
)

pickerInput(
    "unidad_mapa",
    label = "Unidad:",
    choices = unidad_labels,
    selected = "EUR"
)

pickerInput(
    "sector_mapa",
    label = "Sector:",
    choices = c("Total actividades", sort(setdiff(unique(data$sector_name), "Total actividades"))), # Total primero
    selected = "Total actividades"           
)

pickerInput(
    "year_mapa", 
    label = "Año:",
    choices = sort(unique(data$year), decreasing = TRUE) , 
    selected = 2023
)

shinyWidgets::radioGroupButtons(
  inputId = "nuts_mapa",
  label = "NUTS:",
  choices = 0:2,
  selected = 0,
  justified = TRUE
)

opciones_mapa <- data %>%
    filter(NUTS == 0) %>%
    select(full_name, geo) %>% 
    distinct() %>%
    arrange(full_name) %>%
    tibble::deframe()

pickerInput(
    inputId = "seleccion_mapa",
    label = "Selecciona país(es):",
    choices = opciones_mapa,
    selected = NULL,      # <-- Perfecto, empieza vacío
    multiple = TRUE,      # <-- La clave 1: permite selección múltiple
    options = pickerOptions(
        actionsBox = TRUE,
        liveSearch = TRUE,
        noneSelectedText = "Ningún país seleccionado" # Texto que se muestra cuando está vacío
  )
)


# --- Para que no se puedan seleccionar unidades que no existen ---
observe({
    req(input$indicador_mapa) # Confirmamos que haya algo seleccionado
    
    # obtén el código del indicador seleccionado (por ejemplo "D1_SAL_HW")
    indicador_sel <- input$indicador_mapa
    
    # busca las unidades válidas para ese indicador
    unidades_validas <- indicador_unidades[[indicador_sel]]
    
    # filtra tus etiquetas de unidades (para mostrar solo las disponibles)
    unidades_filtradas <- unidad_labels[unidad_labels %in% unidades_validas]
    
    # actualiza el selector de unidad con esas opciones
    updatePickerInput(
        inputId = "unidad_mapa",
        choices = unidades_filtradas,
        selected = unidades_filtradas[1]
    )
})

# --- Para que no se puedan seleccionar sectores que no existen ---
observe({
    req(input$indicador_mapa, input$unidad_mapa) # Confirmamos que haya algo seleccionado
    
    # Filtramos los datos disponibles con los inputs actuales
    sectores_disponibles <- data %>%
        filter(
            item == input$indicador_mapa,
            unit == input$unidad_mapa
        ) %>%
        pull(sector_name) %>%
        unique() %>%
        sort()

    # Actualizamos las opciones del selector de sector
    updatePickerInput(
        inputId = "sector_mapa",
        choices = c("Total actividades", sort(setdiff(unique(sectores_disponibles), "Total actividades"))),
        selected = "Total actividades"
      )
})

observe({
  # 1. Esperamos a tener todos los inputs necesarios
  req(
    input$indicador_mapa,
    input$unidad_mapa,
    input$sector_mapa,
    input$year_mapa
  )
  
  # 2. Filtramos 'data' para encontrar qué países (NUTS 0)
  #    tienen observaciones (values) NO nulas
  #    para la combinación de filtros actual.
  
  paises_con_datos <- data %>%
    filter(
      item == input$indicador_mapa,
      unit == input$unidad_mapa,
      sector_name == input$sector_mapa,
      year == input$year_mapa,
      NUTS == 0,           # Filtramos solo por países
      !is.na(values)       # ¡La clave! Solo los que tienen datos
    ) %>%
    select(full_name, geo) %>% # Seleccionamos el nombre y el ID
    distinct() %>%
    arrange(full_name)
  
  # 3. Creamos el vector nombrado ("Nombre" = "ID")
  opciones_disponibles <- tibble::deframe(paises_con_datos)
  
  # 4. (Opcional pero recomendado) Mantenemos la selección actual
  #    si los países seleccionados siguen estando en la nueva lista.
  
  # Guardamos la selección actual
  seleccion_actual <- isolate(input$seleccion_mapa)
  
  # Vemos cuáles de los seleccionados siguen siendo válidos
  # Usamos 'opciones_disponibles' (el vector nombrado) para 
  # comprobar contra los 'valores' (los códigos "geo")
  nueva_seleccion <- intersect(seleccion_actual, opciones_disponibles)
  
  # Si la intersección da un vector vacío, lo ponemos como NULL
  # para que el pickerInput muestre "Ningún país seleccionado"
  if (length(nueva_seleccion) == 0) {
    nueva_seleccion <- NULL
  }

  # 5. Actualizamos el pickerInput
  updatePickerInput(
    inputId = "seleccion_mapa",
    choices = opciones_disponibles,
    selected = nueva_seleccion # Usamos la selección preservada
  )
  
})
```

<!-- Funciones reactive --> 

```{r}
inputs.processing.mapa0 <- reactive({
    etiqueta_valida <- paste(
        names(indicadores_labels)[match(input$indicador_mapa, indicadores_labels)], 
        "-",
        names(unidad_labels)[match(input$unidad_mapa, unidad_labels)]
    )
    
  tb <- geoj0.tb %>% 
    left_join(
      data %>%
        filter(year==input$year_mapa, item==input$indicador_mapa, unit==input$unidad_mapa, sector_name==input$sector_mapa, NUTS=="0", is.null(input$seleccion_mapa) | (geo %in% input$seleccion_mapa)),
      join_by("NUTS_ID"=="geo")
    ) %>% 
    mutate(full_name = coalesce(full_name, NAME_LATN),
           # crear etiqueta legible combinando indicador y unidad
            indicador_unidad = etiqueta_valida
    )
  
  return(tb)
})
inputs.processing.mapa1 <- reactive({
    etiqueta_valida <- paste(
        names(indicadores_labels)[match(input$indicador_mapa, indicadores_labels)], 
        "-",
        names(unidad_labels)[match(input$unidad_mapa, unidad_labels)]
    )
        
  tb <- geoj1.tb %>% 
    left_join(
      data %>%
        filter(year==input$year_mapa, item==input$indicador_mapa, unit==input$unidad_mapa, sector_name==input$sector_mapa, NUTS=="1",is.null(input$seleccion_mapa) | (substr(geo, 1, 2) %in% input$seleccion_mapa)),
      join_by("NUTS_ID"=="geo")
    ) %>% 
    mutate(full_name = coalesce(full_name, NAME_LATN),
           # crear etiqueta legible combinando indicador y unidad
            indicador_unidad = etiqueta_valida
    )
  return(tb)
})

inputs.processing.mapa2 <- reactive({
    etiqueta_valida <- paste(
        names(indicadores_labels)[match(input$indicador_mapa, indicadores_labels)], 
        "-",
        names(unidad_labels)[match(input$unidad_mapa, unidad_labels)]
    )
    tb <- geoj2.tb %>% 
        left_join(
        data %>%
        filter(year==input$year_mapa, item==input$indicador_mapa, unit==input$unidad_mapa, sector_name==input$sector_mapa, NUTS=="2", is.null(input$seleccion_mapa) | (substr(geo, 1, 2) %in% input$seleccion_mapa)),
      join_by("NUTS_ID"=="geo")
    ) %>% 
    mutate(full_name = coalesce(full_name, NAME_LATN),
           # crear etiqueta legible combinando indicador y unidad
            indicador_unidad = etiqueta_valida
    )
  
  return(tb)
})
```

### 

<!--Tabla-->
```{r}
# imprimimos la tabla con el atributo seleccionado 
renderTable({
  tb <- switch (input$nuts_mapa,
      "0" =  inputs.processing.mapa0(),
      "1" =  inputs.processing.mapa1(),
      "2" =  inputs.processing.mapa2()
  )
  
 tb %>% 
    arrange(desc(values))%>%  
    select(full_name,values) %>% 
    filter(!is.na(values)) %>% 
    mutate(Valor=prettyNum(round(values,
    digits=max(5-nchar(as.character(round(max(na.omit(values))))),0)),
    big.mark = ",")) %>% 
    select(Región = full_name, Valor)
 
})
```



<!-- CREAMOS UNA NUEVA COLUMNA DONDE POR PESTAÑAS PONEMOS UN MAPA COROPLÉTICO Y UN 
     DIAGRAMA DE BARRAS -->

Column {.tabset}
--------------------------------------------------

### Mapa coroplético

```{verbatim}
renderTable({
    tb <- inputs.processing.mapa()
    tb
})
```


```{r}
# dibujamos el mapa coroplético
leaflet::renderLeaflet({
    # capturamos el resultado del procesado de los inputs 
    res <- switch(
        as.character(input$nuts_mapa),
        
        "0" = list(
            tb   = inputs.processing.mapa0(),
            geoj = geoj0
        ),
        "1" = list(
            tb   = inputs.processing.mapa1(),
            geoj = geoj1
        ),
        "2" = list(
            tb   = inputs.processing.mapa2(),
            geoj = geoj2
        )
    )

tb   <- res$tb
geoj <- res$geoj

etiquetas <-paste(
    "<strong> ",tb$full_name ,
    "</strong><br>",tb$indicador_unidad,
    ": ",prettyNum(round(tb$values,digits=2), big.mark = ",", scientific = FALSE)
  )  %>%
 lapply(htmltools::HTML)

 # dibujamos el mapa 
 MapaCoroplético(geoj,tb$values,etiquetas,"Valor")
 
})
```
