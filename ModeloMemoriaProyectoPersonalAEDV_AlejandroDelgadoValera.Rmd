---
title: "Desigualdades regionales y sectoriales en costes laborales y horas trabajadas en la UE"
author: "Alejandro Delgado Valera"
date: "`r Sys.Date()`"
output:
  html_document:
---

<!--
# TRUCOS ÚTILES AL EDITAR UN FICHERO Rmarkdown: 
(1) TECLAS: CTRL-MAY-1 : EDICIÓN DE CÓDIGO OCUPA/NO OCUPA TODA LA VENTANA
(2) TECLAS: CTRL-ALT-C : EJECUTA UN CHUNK CUANDO EL CURSOR DEL RATÓN ESTA DENTRO DEL CHUNK (OTRA FORMA ES HACER CLICK EN EL BOTÓN TRIANGULAR VERDE EN LA ESQUINA SUPERIOR DERECHA DEL CHUNK)
(3) ACTIVAR "knit on Save" PARA COMPILAR AUTOMÁTICAMENTE AL GUARDAR EL ARCHIVO (CTRL-S)
PARA CREAR UN CHUNK NUEVO USAR BOTÓN VERDE CON UNA "C" EN LA PARTE SUPERIOR DERECHA DE LA VENTANA
(4) PARA EJECUTAR UNA PORCIÓN DE CÓDIGO O VISUALIZAR EL VALOR DE UNA TABLA/VARIABLE SELECCIONAR EL CÓDIGO CON EL RATÓN Y HACER CTRL-ENTER -->

<!-- Opcionalmente, el formateo de este documento en HTML se puede mejorar usando CSS --> 

```{css, echo=F}
/* === Estilo general del documento === */
body {
font-family: "Times New Roman", serif;
font-size: 16px;
line-height: 1.6;
color: #222;
background-color: #ffffff;
margin: 40px;
}

/* === Títulos === */
h1, h2, h3, h4 {
font-family: "Times New Roman", serif;
color: #1a1a1a;
margin-top: 1.5em;
margin-bottom: 0.6em;
line-height: 1.25;
}

h1 {
font-size: 1.9em;
border-bottom: 2px solid #444;
padding-bottom: 0.2em;
}

h2 {
font-size: 1.5em;
color: #2a2a2a;
border-left: 4px solid #888;
padding-left: 0.5em;
}

h3 {
font-size: 1.25em;
color: #333;
font-style: italic;
}

/* === Párrafos y texto === */
p {
text-align: justify;
margin-bottom: 1em;
}

/* === Figuras y tablas === */
figure, .figure {
text-align: center;
margin: 1.5em auto;
}

img, .plot {
display: block;
margin: 0 auto;
max-width: 90%;
}

table {
border-collapse: collapse;
margin: 1em auto;
width: 90%;
font-size: 0.95em;
}

th, td {
border: 1px solid #ccc;
padding: 8px 12px;
text-align: center;
}

th {
background-color: #f5f5f5;
font-weight: bold;
}

/* === Pie de figuras === */
.caption {
font-size: 0.9em;
color: #555;
text-align: center;
margin-top: 0.3em;
font-style: italic;
}

/* === Código y chunks === */
pre, code {
font-family: "Courier New", monospace;
background-color: #f8f8f8;
border-radius: 4px;
padding: 2px 5px;
}

pre {
padding: 10px;
overflow-x: auto;
border: 1px solid #e0e0e0;
}

/* === Estilo para las gráficas generadas con ggplot === */
.gm-plot, .ggplot, .plotly, .html-widget svg text {
  font-family: "Times New Roman", serif !important;
  fill: #222222;
}


/* === Márgenes de página === */
@page {
margin: 2.5cm 2cm;
}

```

```{r,echo=FALSE}
# OPCIONES POR DEFECTO AL COMPILAR LOS CHUNKS 
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  cache=F, # ponerlo a TRUE acelera la compilación pues solo recompila los chunks modificados. Es útil al escribir texto con mucho código que tarda tiempo en compilar. Puede fallar cuando unos chunks dependen de otros. En ese caso, o cuando hay errores que no entiendes, borra la carpeta auxiliar que se genera con la extensión "_cache" para obligar a recompilar todo. 
  echo=FALSE
)
```

```{r global, include=FALSE}
# carga de librerías
library(DT)
library(googlesheets4)
library(kableExtra)
library(patchwork)
library(zoo)
library(MASS)
library(flexdashboard)
library(datasets)
library(highcharter) 
library(fpp3)
library(RColorBrewer)
library(openxlsx)  
library(leaflet)  
library(geojsonio)
library(plotly)
library(ggplot2)
library(tidyverse)
library(readr)
library(eurostat)
library(gganimate)

# Cambiar la fuente de las gráficas
theme_set(
    theme_minimal(base_family = "serif") +
    theme(
        text = element_text(family = "serif", color = "#222222"),
        plot.title = element_text(family = "serif", face = "bold", size = 16, hjust = 0.5),
        plot.subtitle = element_text(family = "serif", face = "italic", size = 14, hjust = 0.5),
        axis.title = element_text(family = "serif", face = "bold", size = 14),
        axis.text = element_text(family = "serif", size = 12),
        legend.title = element_text(family = "serif", face = "bold", size = 13),
        legend.text = element_text(family = "serif", size = 12),
        plot.margin = margin(15, 15, 15, 15),
        panel.grid.major = element_line(color = "#e0e0e0"),
        panel.grid.minor = element_blank()
    )
)

# Fuente serif también para textos dentro de los gráficos (geom_text y geom_label)
update_geom_defaults("text", list(family = "serif"))
update_geom_defaults("label", list(family = "serif"))



# asociamos funciones a determinadas librerías para evitar posibles errores 
filter <- dplyr::filter # Filtra filas según condiciones
select <- dplyr::select # Selecciona columnas
mutate <- dplyr::mutate # Crea o modifica columnas
arrange <- dplyr::arrange # Ordena filas
group_by <- dplyr::group_by # Agrupa datos
summarise <- dplyr::summarise # Resume variables (por ejemplo, con medias, conteos)
summarize <- dplyr::summarize # Lo mismo que summarise
rename <- dplyr::rename # Cambia nombres de columnas
distinct <- dplyr::distinct # Elimina filas duplicadas
slice<- dplyr::slice # Selecciona filas por posición
relocate<- dplyr::relocate # Reordena columnas

selectInput <- shiny::selectInput

# Colocamos las funciones en este mismo fichero para evitar dependencias ####

# Función de Pareto
# Dado un vector de números y un nivel de significancia de Pareto, calcula el valor del vector tal que la suma de los valores por encima de ese valor supera el total de la suma multiplicado por el nivel de significancia.

ParetoValue <- function(
        v, # vector numérico
        ParetoSignificancia # número en [0,1] con el grado de significancia de Pareto
){
    
    x <- sort(v,decreasing = TRUE)
    return(x[which(cumsum(x)>=ParetoSignificancia*sum(x))[1]])
}


#FUNCIÓN PARA DIBUJAR UNA PREDICCIÓN DINÁMICA CON USANDO plotly
GraficoDinamicoArima95CI <- function(
 data, # tssible con con los datos originales
 date, # string con el nombre se la variable temporal en data
 value, # string con el nombre se la variable numérica en data
 prediccion, # objeto con la predicción usando ARIMA u otro modelo
 TITLE # título del gráfico
){

  fc <- prediccion %>%
  mutate(lower = NA) %>%
  mutate(upper = NA)

  for(k in 1:nrow(fc)){
    fc$lower[k] <- fc$.mean[k] - 1.96*unlist(fc[[value]][k])[2]
    fc$upper[k] <- fc$.mean[k] + 1.96*unlist(fc[[value]][k])[2]
  }

  data2 <- data
  x <- data2[[date]][1]
  if(!(is.numeric(x) && !inherits(x, "Date") && !inherits(x, "POSIXt"))){
    data2[[date]] <- as.Date(data2[[date]])
    fc[[date]] <- as.Date(fc[[date]])
  }

  # A. Identificamos el último punto real
  ultimo_dato_real <- tail(data2, 1)
  val_real_final   <- ultimo_dato_real[[value]]
  fecha_real_final <- ultimo_dato_real[[date]]
  
  # B. Creamos una fila "falsa" de predicción que es idéntica al dato real
  #    Esto sirve de puente para que plotly una las líneas
  fila_ancla <- fc[1, ] # Copiamos estructura de la primera fila de predicción
  
  fila_ancla[[date]] <- fecha_real_final # Misma fecha que el último real
  fila_ancla$.mean   <- val_real_final   # El valor es el real
  fila_ancla$lower   <- val_real_final   # Límite inf = valor real (sin margen)
  fila_ancla$upper   <- val_real_final   # Límite sup = valor real (sin margen)
  
  # C. Pegamos esta fila AL PRINCIPIO de la predicción
  fc <- dplyr::bind_rows(fila_ancla, fc)


p <- plot_ly() %>%
  add_ribbons(x = fc[[date]], ymin = fc$lower, ymax = fc$upper,
              name = "95% CI", fillcolor = "rgba(0,0,150,0.2)", line = list(width = 0)) %>%
  add_lines(x=fc[[date]], y = fc$.mean, name = "Predicción", line = list(color = "blue")) %>%
  add_lines(x=data2[[date]], y = data2[[value]], name = "Observación", line = list(color = "black")) %>%
  layout(
      # Fuente Sans (Arial) y color gris oscuro (#333333)
      font = list(family = "Arial, sans-serif", color = "#333333"),
      
      # Fondo blanco puro
      paper_bgcolor = "#ffffff",
      plot_bgcolor  = "#ffffff",
      
      # Título en negrita
      title = list(
        text = paste0("<b>", TITLE, "</b>"), 
        font = list(size = 25),
        x = 0.5, 
        xanchor = "center",
        yanchor = "top"
      ),
      
      # Eje X: Cuadrícula gris suave (#dee2e6) y sin bordes negros
      xaxis = list(
        title = list(text = "<b>Año</b>", font = list(size = 17)), 
        showgrid = TRUE,
        gridcolor = "#dee2e6", 
        zeroline = FALSE,
        showline = FALSE,
        tickfont = list(color = "#555555"),
        range(100, 200)
      ),
      
      # Eje Y: Igual que el X
      yaxis = list(
        title = list(text = "<b>Valor</b>", font = list(size = 17)),
        showgrid = TRUE,
        gridcolor = "#dee2e6",
        zeroline = FALSE,
        showline = FALSE,
        tickfont = list(color = "#555555")
      ),
      
      # Leyenda 
      legend = list(
        font = list(weight = "bold", size=15),
        orientation = "v",   # Vertical
        x = 1.02,            # Justo fuera del gráfico a la derecha
        y = 1,               # Alineada arriba
        xanchor = "left",
        yanchor = "top",
        bgcolor = "rgba(0,0,0,0)"
      ),
      
      # Márgenes ajustados
      margin = list(t = 60, b = 40, l = 20, r = 160)
    )



return(p)
}

#FUNCIÓN PARA DIBUJAR UN MAPA COROPLÉTICO USANDO leaflet
MapaCoroplético <- function(
 geoj, # objeto gráfico geojson con los contornos de las regiones
 value, # vector de valores para colorear 
 region_labels, # vector de etiquetas para los desplegables
 legend_title # título de la leyenda 
){

vals <- value[!is.na(value)]

pal <- colorNumeric(
  palette = "YlOrRd",
  domain  = vals
)

p <-  geoj %>%
    leaflet() %>%  
    setView(lng = 7, lat = 50, zoom = 4)  %>% 
    addPolygons(
        fillColor = ~pal(value),
        weight = 1,
        opacity = 1,
        color = "#555555",
        dashArray = "",
        fillOpacity = 0.75,
        highlightOptions = highlightOptions(
            weight = 3,
            color = "#333333",
            dashArray = "",
            fillOpacity = 0.8,
            bringToFront = TRUE
        ),
      label = region_labels 
    ) %>% 
    addLegend("bottomleft", 
      pal = pal, 
      values = na.omit(value),
      title = legend_title,
      labFormat = function(type, cuts, p) {
        n = length(cuts) 
        x = (cuts[-n] + cuts[-1])/2
        x = prettyNum(round(x, digits = 0), big.mark = " ")
        as.character(x)
      },
 
      opacity = 1
      )
  return(p)
}

MapaCoropléticoES <- function(
 geoj, # objeto gráfico geojson con los contornos de las regiones
 value, # vector de valores para colorear 
 region_labels, # vector de etiquetas para los desplegables
 legend_title # título de la leyenda 
){
vals <- value[!is.na(value)]

pal <- colorNumeric(
  palette = "YlOrRd",
  domain  = vals
)

p <-  geoj %>%
    leaflet() %>%  
    setView(lng = -10, lat = 35.8, zoom = 5)  %>% 
    addPolygons(
        fillColor = ~pal(value),
        weight = 1,
        opacity = 1,
        color = "#555555",
        dashArray = "",
        fillOpacity = 0.75,
        highlightOptions = highlightOptions(
            weight = 3,
            color = "#333333",
            dashArray = "",
            fillOpacity = 0.8,
            bringToFront = TRUE
        ),
      label = region_labels 
    ) %>% 
    addLegend("bottomleft", 
      pal = pal, 
      values = na.omit(value),
      title = legend_title,
      labFormat = function(type, cuts, p) {
        n = length(cuts) 
        x = (cuts[-n] + cuts[-1])/2
        x = prettyNum(round(x, digits = 0), big.mark = " ")
        as.character(x)
      },
 
      opacity = 1
      )
  return(p)
}



# CÁLCULO DE LA TRANSFORMACIÓN DE YEO–JOHNSON A PARTIR DE UN VECTOR Y UN VALOR DE lambda 
yeo.johnson <- function(y, lambda) {
  y_t <- numeric(length(y))
  
  # Para y >= 0
  pos_idx <- which(y >= 0)
  if (lambda == 0) {
    y_t[pos_idx] <- log(y[pos_idx] + 1)
  } else {
    y_t[pos_idx] <- ((y[pos_idx] + 1)^lambda - 1) / lambda
  }
  
  # Para y < 0
  neg_idx <- which(y < 0)
  if (lambda == 2) {
    y_t[neg_idx] <- -log(-y[neg_idx] + 1)
  } else {
    y_t[neg_idx] <- -(((-y[neg_idx] + 1)^(2 - lambda) - 1) / (2 - lambda))
  }
  
  return(y_t)
}


# ESTIMACIÓN DE lambda PARA LA TRANSFORMACIÓN DE YEO–JOHNSON DE UN VECTOR y
# OPTIMIZANDO  EL R2 DE LA REGRESIÓN LINEAL CON UN VECTOR x.  
optimize.yeojohnson.R2 <- function(x, y, lambda_range = c(-1, 1.9)) {
 
  # Función objetivo: R² negativo (porque optimize minimiza)
  r2_neg <- function(lambda) {
    y_t <- yeo.johnson(y, lambda)
    modelo <- lm(y_t ~ x)
    return(-summary(modelo)$r.squared)  # queremos maximizar R²
  }
  
  # Optimización de lambda
  opt <- optimize(r2_neg, interval = lambda_range)
  
  # Se retorna el valor óptimo de lambda 
  return(opt$minimum)
}

# FUNCIÓN PARA DIBUJAR LA MATRIZ DE CORRELACIÓN
plot_correlation <- function(
M, # matriz de correlación
show_values = TRUE # flat para controlar si se imprimen los valores en las celdas
) {
  
  # Texto dentro de la celda (2 decimales)
  cell_text <- round(M, 2)
  
  # Escala personalizada: rojo -> blanco -> azul
  custom_colors <- list(
    c(0, "red"),    # mínimo (-1) → azul
    c(0.5, "white"),# 0 → blanco
    c(1, "steelblue")    # máximo (+1) → rojo
  )
  
  # Crear heatmap interactivo
  plot_ly(
    x = colnames(M),
    y = rownames(M),
    z = M,
    type = "heatmap",
    colorscale = custom_colors,
    zmin = -1,
    zmax = 1,
    text = if (show_values) cell_text else NULL,
    texttemplate = if (show_values) "%{text}" else NULL,
    textfont = list(color = "black"),
    hovertemplate = "X: %{x}<br>Y: %{y}<br>Correlación: %{z:.4f}<extra></extra>"
  ) %>%
    layout(
      title = "Matriz de correlación interactiva",
      xaxis = list(title = "", tickangle = 45),
      yaxis = list(title = "", autorange = "reversed")
    )
}
```

<!-- Todos los proyectos personales tienen que tener un cuadro de mandos (Tema 7 de la asignatura) cuya dirección es similar a la que sigue poniendo tu nº de usuario (en lugar de a2405) y el nombre del Rmd asociado. Los cuadros de mando se alojan en un servidor del DIS y solo se puede acceder a ellos a través de la red de la ULPGC o usando VPN -->

[Cuadro de mandos](http://10.22.143.222:3838/sample-apps/a2613/DashboardProyectoPersonalAEDV_AlejandroDelgadoValera.Rmd)  
[Enlace al repositorio en GitHub](https://github.com/aledelgadoo/ProyectoPersonal_AEDV)


<!-- Añadir imagen ilustrativa del tema de mi proyecto --> 
<center>
<img src="images/portada.jpg" width="60%" />
</center>

# Introducción


<!-- situar el tema en un contexto amplio, destacando su relevancia en la actualidad. Delimitar el problema que se aborda en ese contexto amplio --> 


##  Estado actual

<!-- Explicar conceptos claves relacionados con el tema que se aborda. Comentar estudios/resultados precedentes. Identificación de elementos/circunstancias que justifican la realización del estudio sobre este tema. Relevancia y oportunidad de abordar el tema.-->

## Motivación

<!-- Descripción de la motivación que te ha llevado a elegir este tema de trabajo que puede incluir intereses personales/sociales/profesionales --> 

## Objetivos

<!-- Expresa de forma amplia y global el propósito principal del trabajo. Cuales son sus metas principales -->

# Aportaciones del trabajo

<!-- estas sección se suele escribir al final del trabajo --> 

## Principales aportaciones

<!-- Análisis del significado e implicaciones de los resultados en el contexto del área de estudio. Nuevas perspectivas o enfoques. Actualización del conocimiento existente. Debe estar alineado con los objetivos. Comentar cuadro de mandos como aportación  -->


## Alineamiento con los objetivos de desarrollo sostenible

<!-- Hay que rellenar el fichero "ODS.xlsx" con nuestros datos. Si en ChatGPT hacemos la consulta "Relacionar "mi tema de proyecto" con ODS" nos saldrá un borrador de relaciones que podremos usar como base y  perfeccionar. 
--> 

```{r ods}
tb <- read.xlsx("data/ODS.xlsx") %>%
  as_tibble()
tb[is.na(tb)] <- ""

colnames(tb) <- c("ODS","No procede", "Bajo", "Medio","Alto")
tabla <- kable(tb,caption="Grado de relación del proyecto con los objetivos de desarrollo sostenible (ODS)", 
                format = "html",
                table.attr = 'style="width:500px; margin-left: auto; margin-right: auto;"',
                booktabs = FALSE,        # <— desactiva el estilo "limpio" sin líneas
                linesep = "") %>%            # <— evita espacios innecesarios entre filas) 
    
        kable_styling(
        bootstrap_options = c("striped", "bordered", "condensed"), # añade bordes
        full_width = FALSE,
        position = "center")
                
tabla %>% column_spec(2, extra_css = "text-align: center;") %>%
          column_spec(3, extra_css = "text-align: center;") %>%
          column_spec(4, extra_css = "text-align: center;") %>%
          column_spec(5, extra_css = "text-align: center;")
```


# Desarrollo


## Herramientas empleadas

<!-- mencionar y justificar para este trabajo el uso de R, RStudio y las librerías principales utilizadas. Mencionar también el servidor shiny del DIS para desplegar públicamente el cuadro de mandos    --> 

## Metodología

Utilizaremos la metodología de desarrollo CRISP-DM (Cross Industry Standard Process for Data Mining) que es un marco ampliamente utilizado para proyectos de Ciencias de Datos. En la siguiente figura se presenta un diagrama con las diferentes fases de esta metodología que a continuación describimos con más detalle: 

<center>
<img src="https://ctim.es/AEDV/1200px-CRISP-DM_Process_Diagram1.5x.png" width="40%" />
<p style="font-size: 14px; color: gray;"><em>Diagrama metodología de desarrollo CRISP-DM</em></p>
</center>



* **Comprensión del negocio**. Se plantean los objetivos del proyecto y la búsqueda de información y datos. 

<!-- Una parte de esta fase incluye la descripción del objeto del proyecto y sus objetivos, como eso ya se ha presentado anteriormente en la memoria no se repite aquí. Otra parte que si se incluye es describir lo que se ha hecho para  la búsqueda de datos, las fuentes consultadas, entrevistas, lecturas bibliográficas, etc.. señalando las incidencias/dificultades encontradas, así como el análisis de la fiabilidad de la información obtenida. En esta fase no se realiza una descripción detallada de los datos ni pondremos gráficas.  -->


* **Comprensión de los datos**. Se analiza la  estructura y organización de los datos obtenidos. Se identifican posible problemas como datos faltantes, outliers o inconsistencias. 

<!-- Identificar y describir con claridad el significado de las variables categóricas existentes (y todos los valores que pueden tomar) y las observaciones (habitualmente valores numéricos). Identificar si los datos están organizados de forma ordenada (tidy), es decir una sola observación por cada fila de la tabla acompañada de variables categóricas o de forma no ordenada, es decir, varias observaciones por cada fila. En este caso,  habitualmente, los valores posibles de una variable categórica se distribuyen como títulos de columnas de la tabla y cada celda de esas columnas incluye una observación. Estudiar la frecuencia (Nº de observaciones) asociadas a las variables categóricas, el tamaño e intervalo temporal de las series temporales (si procede), la distribución del nº de observaciones por regiones, o por otro tipo de desglose de la información (si procede), análisis de los atributos combinados existentes, dados por las combinaciones de variables categóricas que aparecen en el dataset. Analizar en más detalle (si hubiera lugar) como son los datos en la regiones que más me interesan. Identificación de errores, valores ausentes, outliers o cualquier otra incosistencia encontrada. 

En esta fase no se realiza procesado de datos salvo el mínimo para obtener la información que se requiere. Tampoco se entra a valorar la calidad de los datos o como habría que procesarlos. En términos médicos, esta sería la fase del diagnóstico donde todavía no se comenta nada del pronóstico del paciente o del tratamiento. Por tanto no se expresan opiniones sobre los datos, solo se exponen tal cual son. 

En esta fase, en general, no pondremos gráficos, salvo cosas muy sencillas relativas a las frecuencias de los datos y cosas de ese tipo, pues los gráficos requieren, en general, selección y procesamiento de datos previo. 

El análisis de los datos realizado para la validación del tema del proyecto personal va en este apartado. 

--> 
 
* **Preparación de los datos**. Se realiza limpieza, transformación, combinación y selección/creación de variables relevantes para el análisis

<!-- En esta fase, a partir de los resultados de la fase anterior, estudiamos la relevancia y calidad de la información obtenida en la fase anterior de acuerdo con los objetivos del proyecto, si procede seleccionamos/eliminamos variables categóricas o algunas de sus opciones, exponiendo con claridad y justificadamente los atributos combinados (formados por combinaciones de variables categóricas) que vamos a usar en el estudio. Decidimos el intervalo temporal que vamos a usar para  nuestro estudio. Realizamos la limpieza, transformación,  creación de nuevas variables, combinación de tablas,etc... En esta fase pondremos las gráficas que ilustran los datos una vez procesados y seleccionados pero sin usar los modelos que se formulan en la siguiente fase.  --> 

* **Modelado**. Selección y aplicación de los modelos adecuados para analizar los datos 

<!-- Se aplican a los datos los modelos utilizados, como por ejemplo, regresión lineal, modelos ARIMA, matriz de correlación, PCA, etc.. En esta fase se pondrán gráficas sobre el uso de de estos modelos.  --> 

* **Evaluación**. Evaluar si el modelo responde a las preguntas de investigación, comparación con otros métodos 

<!-- Se discuten de forma crítica los resultados obtenidos incluyendo pruebas de evaluación / validación realizadas (si procede) --> 

* **Despliegue**. Comunicación del trabajo en una memoria y diseño y elaboración de un cuadro de mandos para presentar los resultados de forma eficaz y atractiva. 

<!-- El despliegue de este proyecto se realizará a través de la confección de esta memoria y de un cuadro de mandos. --> 

 
 <!-- De acuerdo con esta metodología, los resultados se van presentando, discutiendo y validando a lo largo de las fases de **Modelado**, **Evaluación** y **Despliegue** y, por tanto, para mantener una estructura coherente de la memoria, de acuerdo con la aplicación de la  metodología CRISP-DM, no existe en la memoria una sección separada de presentación de resultados.  --> 
 
 
 Es importante observar que esta metodología es iterativa, es decir que los resultados obtenidos en algunas de las fases puede afectar al desarrollo de fases anteriores. 
 
 A continuación se describirá en detalle como se han abordado cada una de las fases del desarrollo del proyecto siguiendo esta metodología.


## Comprensión del negocio
<!-- desarrollo de esta fase -->

Para garantizar la idoneidad de los datos respecto a los objetivos de la asignatura y la capacidad de cómputo disponible, se estableció un protocolo de búsqueda y selección estructurado en tres fases:  

#### Fase 1: Filtrado Cuantitativo y Dimensional  
Partiendo del repositorio de fuentes oficiales proporcionado por la docencia, se aplicó un primer filtro basado en requisitos técnicos y dimensionales. Se priorizaron conjuntos de datos con una extensión temporal significativa (series temporales largas) y un volumen de observaciones manejable pero suficiente para el análisis profundo (rango objetivo entre 10 mil y 10 mill registros). Este criterio aseguró un equilibrio entre la riqueza de información y la viabilidad del procesamiento computacional.

#### Fase 2: Evaluación Temática y Potencial Analítico  
Sobre los datasets resultantes, se realizó una exploración cualitativa asistida por herramientas de Inteligencia Artificial (LLMs) para analizar rápidamente los metadatos y descripciones. El objetivo fue identificar temáticas con alto potencial narrativo y relevancia socioeconómica.Se cruzaron las características de los candidatos con los contenidos teóricos del manual de la asignatura (Introducción al Análisis de Datos y Visualización), buscando variables que permitieran aplicar las técnicas de visualización avanzad as (mapas, series temporales, comparativas categóricas) exigidas en el proyecto.

#### Fase 3: Validación Normativa y Selección Definitiva  
Tras la preselección de un primer candidato y su posterior descarte por no ajustarse estrictamente a la totalidad de los requisitos de la rúbrica (específicamente en la granularidad de las variables), se procedió a la elección final del dataset `nama_10r_2lp10`. Este conjunto de datos superó la validación final al cumplir con todos los criterios: estructura tidy, presencia de variables categóricas y numéricas, desglose geográfico (NUTS 2) y una serie temporal completa (1995-2023), permitiendo el análisis multinivel (Europa-España-Canarias) propuesto.

## Comprensión de los datos
<!-- desarrollo de esta fase -->

### Información general del dataset
```{r, echo=F}
# LEER EL DATASET QUE HEMOS ALMACENADO EN MEMORIA
dataset.name <- "nama_10r_2lp10"

dataset.original <- read_csv(paste0("data/", dataset.name, ".csv")) %>%
  as_tibble()

dataset.info <- read_csv(paste0("data/", dataset.name, "_info.csv")) %>% 
    as_tibble()

data <- dataset.original %>% 
    arrange(TIME_PERIOD,geo)
```

- **code**: `r dataset.info$code[1]`
- **title**: `r dataset.info$title[1]`
- **last.update.of.data**: `r dataset.info$last.update.of.data[1]`
- **last.table.structure.change**: `r dataset.info$last.table.structure.change[1]`
- **data.start**: `r dataset.info$data.start[1]`
- **data.end**: `r dataset.info$data.end[1]`
- **values**: `r format(dataset.info$values[1],big.mark = ".")`

### Explicación de variables categóricas

Los datos de nuestro dataset están organizados de forma tidy. Los variables categóricas que existen, su significado, y sus valores posibles son:

- **freq**: Frecuencia con la que se toman las observaciones. Tiene un único valor "A", que corresponde a datos anuales.

- **nace_r2**: Rama de actividad económica. Se divide según la clasificación NACE Rev. 2. *Los códigos pueden corresponder a una sección concreta (ej. A, C, F), a un rango de secciones consecutivas indicado con guion (ej. B-E, G-I), o a agrupaciones específicas de varias secciones señaladas con guion bajo (ej. M_N).*  
Valores posibles: 
  - TOTAL: Total - todas las actividades NACE  
  - O-U: Administración pública y defensa; actividades de computación obligatoria; educación; salud humana y servicios sociales; artes, entretenimiento y otros servicios  
  - O-Q: Administración pública, defensa, educación, actividades sanitarias y de servicios sociales  
  - B-E: Industria (excepto construcción)  
  - K-N: Actividades financieras y de seguros; inmobiliarias; profesionales, científicas y técnicas; servicios administrativos 
  - F: Construcción  
  - M_N: Actividades profesionales, científicas y técnicas; actividades administrativas y servicios auxiliares
  - A: Agricultura, silvicultura y pesca  
  - C: Industria manufacturera  
  - G-J: Comercio mayorista y minorista; transporte; alojamiento; información y comunicación  
  - R-U: Artes, entretenimiento y recreación; otros servicios  
  - G-I: Comercio mayorista y minorista; transporte; alojamiento y servicios de comida  
  - J: Información y comunicaciones  
  - K: Actividades financieras y de seguros  
  - L: Actividades inmobiliarias  
<br>

- **na_item**: Tipo de indicador económico relacionado con los costes laborales y las horas trabajadas.  

  - D1_SAL_HW: Coste laboral por hora trabajada, que incluye sueldos, salarios y cotizaciones sociales pagadas por el empleador (*euros por hora*).  
  - D1_SAL_PER: Coste laboral medio por persona empleada, considerando tanto la remuneración directa como las contribuciones sociales a cargo de la empresa (*euros por empleado*).  
  - HW_EMP: Horas efectivamente trabajadas por persona empleada en promedio, es decir, el total de horas dedicadas al trabajo dividido entre el número de empleados (*horas por empleado*).  
<br> 

- **unit**: Unidad de medida de los valores registrados para cada indicador.  

  - EUR: Euro  
  - NAC: Moneda nacional  
  - PC_EU27_2020_MEUR_CP: Porcentaje del total de la UE27 (desde 2020) en precios corrientes  
  - HW: Horas trabajadas  
  - PCH_PRE: Variación porcentual respecto al periodo anterior  
<br>

- **geo**: Regiones para las que existen observaciones.

  - NUTS 0: 29 países  
  - NUTS 1: 95 regiones  
  - NUTS 2: 249 comunidades  
  - EU27_2020: promedio de la Unión Europea compuesto por los 27 países miembros vigentes desde el año 2020    
  - OTHERS: 20 códigos que no corresponden a regiones reales  
<br>
  
- **TIME_PERIOD**: Fechas de las observaciones. Comprende datos desde 1995 hasta 2023, con observaciones anuales. La cantidad de registros por año varía, siendo especialmente elevada entre 2000 y 2021, destacando los años 2016 y 2020 como los que concentran más observaciones. Cabe destacar que en 2023 el número de registros disminuye significativamente respecto a años anteriores.  

```{r}
# CÓDIGOS NUTS DE REGIONES REALES PRESENTES EN LOS MAPAS NUTS ACTUALES

NUTS0_codes <- c("EL", "ES", "FI", "FR", "HR", "HU", "IE", "IS", "AL", "AT", "BA", "BE", "BG", "CH", "CY", "CZ", "DE", "DK", "EE", "IT", "LI", "LT", "LU", "LV", "ME", "MK", "MT", "NL", "NO", "PL", "PT", "RO", "RS", "SE", "SI", "SK", "TR", "UA", "XK")

NUTS1_codes <- c("DEA", "DEB", "DEC", "DED", "DEE", "DEF", "DEG", "DK0", "EE0", "EL3", "EL4", "EL5", "EL6", "ES1", "ES2", "ES3", "ES4", "ES5", "ES6", "ES7", "FI1", "AL0", "AT1", "AT2", "AT3", "BA0", "BE1", "BE2", "BE3", "BG3", "BG4", "CH0", "CY0", "CZ0", "DE1", "DE2", "DE3", "DE4", "DE5", "DE6", "DE7", "DE8", "DE9", "HR0", "HU1", "HU2", "HU3", "IE0", "IS0", "ITC", "ITF", "ITG", "ITH", "ITI", "LI0", "XK0", "LT0", "LU0", "LV0", "ME0", "MK0", "MT0", "NL1", "NL2", "NL3", "NL4", "NO0", "PL2", "PL4", "PL5", "PL6", "PL7", "PL8", "PL9", "PT1", "PT2", "PT3", "RO1", "RO2", "RO3", "RO4", "RS1", "RS2", "SE1", "SE2", "SE3", "SI0", "SK0", "TR1", "TR2", "TR3", "TR4", "TR5", "TR6", "TR7", "TR8", "TR9", "TRA", "TRB", "TRC", "FI2", "FR1", "FRB", "FRC", "FRD", "FRE", "FRF", "FRG", "FRH", "FRI", "FRJ", "FRK", "FRL", "FRM", "FRY")

NUTS2_codes <- c("DE12", "DE13", "DE14", "DE21", "DE22", "DE23", "DE24", "DE25", "DE26", "DE27", "DE30", "DE40", "DE50", "DE60", "DE71", "DE72", "DE73", "DE80", "DE91", "DE92", "DE93", "DE94", "DEA1", "DEA2", "DEA3", "DEA4", "DEA5", "DEB1", "DEB2", "DEB3", "DEC0", "DED2", "DED4", "DED5", "DEE0", "DEF0", "DEG0", "DK01", "AL01", "AL02", "AL03", "AT11", "AT12", "AT13", "AT21", "AT22", "AT31", "AT32", "AT33", "AT34", "BA01", "BA02", "BA03", "BE10", "BE21","BE22", "BE23", "BE24", "BE25", "BE31", "BE32", "BE33", "BE34", "BE35", "BG31", "BG32", "BG33", "BG34", "BG41", "BG42", "CH01", "CH02", "CH03", "CH04", "CH05", "CH06", "CH07", "CY00", "CZ01", "CZ02", "CZ03", "CZ04", "CZ05", "CZ06", "CZ07", "CZ08", "DE11", "MK00", "MT00", "NL11", "NL12", "NL13", "NL21", "NL22", "NL23", "NL32", "NL34", "NL35", "NL36", "NL41", "NL42", "NO02", "NO06", "NO07", "NO08", "NO09", "NO0A", "NO0B", "PL21", "PL22", "PL41", "PL42", "PL43", "PL51", "PL52", "PL61", "PL62", "PL63", "PL71", "PL72", "PL81", "PL82", "PL84", "PL91", "PL92", "PT11", "PT15", "PT19", "PT1A", "PT1B", "PT1C", "DK02", "DK03", "DK04", "DK05", "EE00", "EL30", "EL41", "EL42", "EL43", "EL51", "EL52", "EL53", "EL54", "EL61", "EL62", "EL63", "EL64", "EL65", "ES11", "ES12", "ES13", "ES21", "ES22", "ES23", "ES24", "ES30", "ES41", "ES42", "ES43", "ES51", "ES52", "ES53", "ES61", "ES62", "ES63", "ES64", "ES70", "FI19", "FI1B", "FI1C", "FI1D", "FI20", "FR10", "FRB0", "FRC1", "FRC2", "FRD1", "FRD2", "FRE1", "FRE2", "FRF1", "FRF2", "FRF3", "FRG0", "FRH0", "FRI1", "FRI2", "FRI3", "FRJ1", "FRJ2", "FRK1", "FRK2", "FRL0", "FRM0", "FRY1", "FRY2", "FRY3", "FRY4", "FRY5", "HR02", "HR03", "HR05", "HR06", "HU11", "HU12", "HU21", "HU22", "HU23", "HU31", "HU32", "HU33", "IE04", "IE05", "IE06", "IS00", "ITC1", "ITC2", "ITC3", "ITC4", "ITF1", "ITF2", "ITF3", "ITF4", "ITF5", "ITF6", "ITG1", "ITG2", "ITH1", "ITH2", "ITH3", "ITH4", "ITH5", "ITI1", "ITI2", "ITI3", "ITI4", "LI00", "LT01", "LT02", "LU00", "LV00", "ME00", "SE33", "SI03", "SI04", "SK01", "SK02", "SK03", "SK04", "TR10", "TR21", "TR22", "TR31", "TR32", "TR33", "TR41", "TR42", "TR51", "TR52", "TR61", "TR62", "TR63", "TR71", "TR72", "TR81", "TR82", "TR83", "TR90", "TRA1", "TRA2", "TRB1", "TRB2", "TRC1", "TRC2", "TRC3", "XK00", "PT1D", "PT20", "PT30", "RO11", "RO12", "RO21", "RO22", "RO31", "RO32", "RO41", "RO42", "RS11", "RS12", "RS21", "RS22", "SE11", "SE12", "SE21", "SE22", "SE23", "SE31", "SE32")

NUTS3_codes <- c("AT333", "AT334", "AT335", "AT341", "AT342", "BE100", "BE211", "BE212", "BE213", "BE223", "BE224", "BE225", "BE231", "BE232", "BE233", "BE234", "BE235", "BE236", "BE241", "BE242", "BE251", "BE252", "BE253", "BE254", "BE255", "BE256", "BE257", "BE258", "BE310", "BE323", "BE328","BE329", "BE32A", "BE32B", "BE32C", "BE32D", "BE331", "BE332", "BE334", "BE335", "BE336", "BE341", "BE342", "BE343", "BE344", "BE345", "BE351", "BE352", "BE353", "BG311", "BG312", "BG313", "BG314", "BG315", "BG321", "BG322", "BG323", "BG324", "BG325", "BG331", "BG332", "BG333", "BG334", "BG341", "BG342", "BG343", "BG344", "BG411", "BG412", "BG413", "BG414", "BG415", "BG421", "BG422", "BG423", "BG424", "BG425", "CH011", "CH012", "CH013", "CH021", "CH022", "CH023", "CH024", "CH025", "CH031", "CH032", "CH033", "CH040", "CH051", "CH052", "CH053", "CH054", "CH055", "CH056", "CH057", "CH061", "CH062", "CH063", "CH064", "CH065", "CH066", "CH070", "CY000", "CZ010", "CZ020", "CZ031", "CZ032", "CZ041", "CZ042", "CZ051", "CZ052", "CZ053", "CZ063", "CZ064", "CZ071", "CZ072", "CZ080", "DE111", "DE112", "DE113", "DE114", "DE115", "DE116", "DE117", "DE118", "DE119", "DE11A", "DE11B", "DE11C", "DE11D", "DE121", "DE122", "DE123", "DE124", "DE125", "DE126", "DE127", "DE128", "DE129", "DE12A", "DE12B", "DE12C", "DE131", "DE132", "DE133", "DE134", "DE135", "DE136", "DE137", "DE138", "DE139", "DE13A", "DE141", "DE142", "DE143", "DE144", "DE145", "DE146", "DE147", "DE148", "DE149", "DE211", "DE212", "AL011", "AL012", "AL013", "AL014", "AL015", "AL021", "AL022", "AL031", "AL032", "AL033", "AL034", "AL035", "AT111", "AT112", "AT113", "AT121", "AT122", "AT123", "AT124", "AT125", "AT126", "AT127", "AT130", "AT211", "AT212", "AT213", "AT221", "AT222", "AT223", "AT224", "AT225", "AT226", "AT311", "AT312", "AT313", "AT314", "AT315", "AT321", "AT322", "AT323", "AT331", "AT332", "DE238", "DE239")

NUTS3_codes <-c(NUTS3_codes, "DE23A", "DE241", "DE242", "DE243", "DE244", "DE245", "DE246", "DE247", "DE248", "DE249", "DE24A", "DE24B", "DE24C", "DE24D", "DE251", "DE252", "DE253", "DE254", "DE255", "DE256", "DE257", "DE258", "DE259", "DE25A", "DE25B", "DE25C", "DE261", "DE262", "DE263", "DE264", "DE265", "DE266", "DE267", "DE268", "DE269", "DE26A", "DE26B", "DEA5C", "DEB11", "DEB12", "DEB13", "DEB14", "DEB15", "DEB17", "DEB18", "DEB1A", "DEB1B", "DEB1C", "DEB1D", "DEB21", "DEB22", "DEB23", "DEB24", "DEB25", "DEB31", "DEB32", "DEB33", "DEB34", "DEB35", "DEB36", "DEB37", "DEB38", "DEB39", "DEB3A", "DEB3B", "DEB3C", "DEB3D", "DEB3E", "DEB3F", "DEB3G", "DEB3H", "DEB3I", "DEB3J", "DEB3K", "DEC01", "DEC02", "DEC03", "DEC04", "DEC05", "DEC06", "DED21", "DED2C", "DED2D", "DED2E", "DED2F", "DED41", "DED42", "DED43", "DED44", "DED45", "DED51", "DED52", "DED53", "DEE01", "DEE02", "DEE03", "DEE04", "DEE05", "DEE06", "DEE07", "DEE08", "DEE09", "DEE0A", "DEE0B", "DEE0C", "DEE0D", "DEE0E", "DEF01", "DEF02", "DEF03", "DEF04", "DEF05", "DEF06", "DEF07", "DEF08", "DEF09", "DEF0A", "DEF0B", "DEF0C", "DEF0D", "DEF0E", "DEF0F", "DEG01", "DEG02", "DE26C", "DE271", "DE272", "DE273", "DE274", "DE275", "DE276", "DE277", "DE278", "DE279", "DE27A", "DE27B", "DE27C", "DE27D", "DE27E", "DE300", "DE401", "DE402", "DE403", "DE404", "DE405", "DE406", "DE407", "DE408", "DE409", "DE40A", "DE40B", "DE40C", "DE40D", "DE40E", "DE40F", "DE40G", "DE40H", "DE40I", "DE501", "DE502", "DE600", "DE711", "DE712", "DE713", "DE714", "DE715", "DE716", "DE717", "DE718", "DE719", "DE71A", "DE71B", "DE71C", "DE71D", "DE71E", "DE721", "DE722", "DE723", "DE724", "DE725", "DE731", "DE732", "DE733", "DE734", "DE735", "DE736", "DE737", "DE803", "DE804", "DE80J", "DE80K", "DE80L", "DE80M", "DE80N", "DE80O", "DE911", "DE912", "DE913", "DE914", "DE916", "DE917", "DE918", "DE91A", "DE91B", "DE91C", "DE922", "DE923", "DE925", "DE926", "DE927", "DE928", "DE929", "DE931", "DE932", "DE933", "DE934", "DE935", "DE936", "DE937", "DE938", "DE939", "DE93A", "DE93B", "DE941", "DE942", "DE943", "DE944", "DE945", "DE946", "DE947", "DE948", "DE949", "DE94A", "DE94B", "DE94C", "DE94D")

NUTS3_codes <-c(NUTS3_codes, "DE94E", "DE94F", "DE94G", "DE94H", "DEA11", "DEA12", "DEA13", "DEA14", "DEA15", "DEA16", "DEA17", "DEA18", "DEA19", "DEA1A", "DEA1B", "DEA1C", "DEA1D", "DEA1E", "DEA1F", "DEA22", "DEA23", "DEA24", "DEA26", "DEA27", "DEA28", "DEA29", "DEA2A", "DEA2B", "DEA2C", "DEA2D", "DEA31", "DEA32", "DEA33", "DEA34", "DEA35", "DEA36", "DEA37", "DEA38", "DEA41", "DEA42", "DEA43", "DEA44", "DEA45", "DEA46", "DEA47", "DEA51", "DEA52", "DEA53", "DEA54", "DEA55", "DEA56", "DEA57", "DEA58", "DEA59", "DEA5A", "DEA5B", "DE213", "DE214", "DE215", "DE216", "DE217", "DE218", "DE219", "DE21A", "DE21B", "DE21C", "DE21D", "DE21E", "DE21F", "DE21G", "DE21H", "DE21I", "DE21J", "DE21K", "DE21L", "DE21M", "DE21N", "DE221", "DE222", "DE223", "DE224", "DE225", "DE226", "DE227", "DE228", "DE229", "DE22A", "DE22B", "DE22C", "DE231", "DE232", "DE233", "DE234", "DE235", "DE236", "DE237", "FRD11", "FRD12", "FRD13", "FRD21", "FRD22", "FRE11", "FRE12", "FRE21", "FRE22", "FRE23", "FRF11", "FRF12", "FRF21", "FRF22", "FRF23", "FRF24", "FRF31", "FRF32", "FRF33", "FRF34", "FRG01", "FRG02", "FRG03", "FRG04", "FRG05", "FRH01", "FRH02", "FRH03", "FRH04", "FRI11", "FRI12", "FRI13", "FRI14", "FRI15", "FRI21", "FRI22", "FRI23", "FRI31", "FRI32", "FRI33", "FRI34", "FRJ11", "FRJ12", "FRJ13", "FRJ14", "FRJ15", "FRJ21", "FRJ22", "FRJ23", "FRJ24", "FRJ25", "FRJ26", "FRJ27", "FRJ28", "FRK11", "FRK12", "FRK13", "FRK14", "FRK21", "FRK22", "FRK23", "FRK24", "FRK25", "FRK26", "FRK27", "FRK28", "FRL01", "FRL02", "FRL03", "FRL04", "FRL05", "FRL06", "FRM01", "FRM02", "FRY10", "FRY20", "DEG03", "DEG05", "DEG06", "DEG07", "DEG09", "DEG0A", "DEG0C", "DEG0D", "DEG0E", "DEG0G", "DEG0J", "DEG0K", "DEG0L", "DEG0M", "DEG0Q", "DEG0R", "DEG0S", "DEG0T", "DEG0U", "DEG0V", "DK011", "DK012", "DK013", "DK014", "DK021", "DK022", "DK031", "DK032", "DK041", "DK042", "DK050", "EE001", "EE004", "EE008", "EE009", "EE00A", "EL301", "EL302", "EL303", "EL304", "EL305", "EL306", "EL307", "EL411", "EL412", "EL413", "EL421", "EL422", "EL431", "EL432", "EL433", "EL434", "EL511", "EL512", "EL513", "EL514", "EL515", "EL521", "EL522", "EL523", "EL524", "EL525", "EL526", "EL527")

NUTS3_codes <-c(NUTS3_codes, "EL531", "EL532", "EL533", "EL541", "EL542", "EL543", "EL611", "EL612", "EL613", "EL621", "EL622", "EL623", "EL624", "EL631", "EL632", "EL633", "EL641", "EL642", "EL643", "EL644", "EL645", "EL651", "EL652", "EL653", "ES111", "ES112", "ES113", "ES114", "ES120", "ES130", "ES211", "ES212", "ES213", "ES220", "ES230", "ES241", "ES242", "ES243", "ES300", "ES411", "ES412", "ES413", "ES414", "ES415", "ES416", "ES417", "ES418", "ES419", "ES421", "ES422", "ES423", "ES424", "ES425", "ES431", "ES432", "ES511", "ES512", "ES513", "ES514", "ES521", "ES522", "ES523", "ES531", "ES532", "ES533", "ES611", "ES612", "ES613", "ES614", "ES615", "ES616", "ES617", "ES618", "ES620", "ES630", "ES640", "ES703", "ES704", "ES705", "ES706", "ES707", "ES708", "ES709", "FI196", "FI198", "FI199", "FI19A", "FI19B", "FI1B1", "FI1C1", "FI1C2", "FI1C5", "FI1C6", "FI1C7", "FI1D5", "FI1D7", "FI1D8", "FI1D9", "FI1DA", "FI1DB", "FI1DC", "FI200", "FR101", "FR102", "FR103", "FR104", "FR105", "FR106", "FR107", "FR108", "FRB01", "FRB02", "FRB03", "FRB04", "FRB05", "FRB06", "FRC11", "FRC12", "FRC13", "FRC14", "FRC21", "FRC22", "FRC23", "FRC24", "HU313", "HU321", "HU322", "HU323", "HU331", "HU332", "HU333", "IE041", "IE042", "IE051", "IE052", "IE053", "IE061", "IE062", "IE063", "IS001", "IS002", "ITC11", "ITC12", "ITC13", "ITC14", "ITC15", "ITC16", "ITC17", "ITC18", "ITC20", "ITC31", "ITC32", "ITC33", "ITC34", "ITC41", "ITC42", "ITC43", "ITC44", "ITC46", "ITC47", "ITC48", "ITC49", "NL415", "NL416", "NL421", "NL422", "NL423", "NO020", "NO060", "NO071", "NO072", "NO073", "NO081", "NO083", "NO084", "NO085", "NO092", "NO093", "NO094", "NO0A1", "NO0A2", "NO0A3", "NO0B1", "NO0B2", "PL213", "PL214", "PL217", "PL218", "PL219", "PL21A", "PL224", "PL225", "PL227", "PL228", "PL229", "PL22A", "PL22B", "PL22C", "PL411", "PL414", "PL415", "PL416", "PL417", "PL418", "PL424", "PL426", "PL427", "PL428", "PL431", "PL432", "PL514", "PL515", "PL516", "PL517", "PL518", "PL523", "PL524", "PL613", "PL616", "PL617", "PL618", "PL619", "PL621", "PL622", "PL623", "PL633", "PL634", "PL636", "PL637", "PL638", "PL711", "PL712", "ITC4A", "ITC4B", "ITC4C", "ITC4D")

NUTS3_codes <-c(NUTS3_codes, "ITF11", "ITF12", "ITF13", "ITF14", "ITF21", "ITF22", "ITF31", "ITF32", "ITF33", "ITF34", "ITF35", "ITF43", "ITF44", "ITF45", "ITF46", "ITF47", "ITF48", "ITF51", "ITF52", "ITF61", "ITF62", "ITF63", "ITF64", "ITF65", "ITG11", "ITG12", "ITG13", "ITG14", "ITG15", "ITG16", "ITG17", "ITG18", "ITG19", "ITG2D", "ITG2E", "ITG2F", "ITG2G", "ITG2H", "ITH10", "ITH20", "ITH31", "ITH32", "ITH33", "ITH34", "ITH35", "ITH36", "ITH37", "ITH41", "ITH42", "ITH43", "ITH44", "ITH51", "ITH52", "ITH53", "ITH54", "ITH55", "ITH56", "ITH57", "ITH58", "ITH59", "ITI11", "ITI12", "ITI13", "ITI14", "ITI15", "ITI16", "ITI17", "ITI18", "ITI19", "ITI1A", "ITI21", "ITI22", "ITI31", "ITI32", "ITI33", "ITI34", "ITI35", "ITI41", "ITI42", "ITI43", "ITI44", "ITI45", "LI000", "LT011", "LT021", "LT022", "LT023", "LT024", "LT025", "LT026", "LT027", "LT028", "LT029", "LU000", "LV005", "LV009", "LV00A", "LV00B", "LV00C", "ME000", "MK001", "MK002", "MK003", "MK004", "MK005", "MK006", "MK007", "MK008", "MT001", "MT002", "NL112", "NL114", "NL115", "NL126", "NL127", "NL128", "NL131", "NL132", "NL133", "NL211", "NL212", "NL213", "NL221", "NL224", "NL225", "NL226", "NL230", "NL321", "NL323", "NL325", "NL327", "NL328", "NL32A", "NL32B", "NL341", "NL342", "NL350", "NL361", "NL362", "NL363", "NL364", "NL365", "NL366", "NL411", "NL414", "FRY30", "FRY40", "FRY50", "HR021", "HR022", "HR023", "HR024", "HR025", "HR026", "HR027", "HR028", "HR031", "HR032", "HR033", "HR034", "HR035", "HR036", "HR037", "HR050", "HR061", "HR062", "HR063", "HR064", "HR065", "HU110", "HU120", "HU211", "HU212", "HU213", "HU221", "HU222", "HU223", "HU231", "HU232", "HU233", "HU311", "HU312", "TR412", "TR413", "TR421", "TR422", "TR423", "TR424", "TR425", "TR510", "TR521", "TR522", "TR611", "TR612", "TR613", "TR621", "TR622", "TR631", "TR632", "TR633", "TR711", "TR712", "TR713", "TR714", "TR715", "TR721")

NUTS3_codes <-c(NUTS3_codes, "TR722", "TR723", "TR811", "TR812", "TR813", "TR821", "TR822", "TR823", "TR831", "TR832", "TR833", "TR834", "TR901", "TR902", "TR903", "TR904", "TR905", "TR906", "TRA11", "TRA12", "TRA13", "TRA21", "TRA22", "TRA23", "TRA24", "TRB11", "TRB12", "TRB13", "TRB14", "TRB21", "TRB22", "TRB23", "TRB24", "TRC11", "TRC12", "TRC13", "TRC21", "TRC22", "TRC31", "TRC32", "TRC33", "TRC34", "PL713", "PL714", "PL715", "PL721", "PL722", "PL811", "PL812", "PL814", "PL815", "PL821", "PL822", "PL823", "PL824", "PL841", "PL842", "PL843", "PL911", "PL912", "PL913", "PL921", "PL922", "PL923", "PL924", "PL925", "PL926", "PT111", "PT112", "PT119", "PT11A", "PT11B", "PT11C", "PT11D", "PT11E", "PT150", "PT191", "PT192", "PT193", "PT194", "PT195", "PT196", "PT1A0", "PT1B0", "PT1C1", "PT1C2", "PT1C3", "PT1C4", "PT1D1", "PT1D2", "PT1D3", "PT200", "PT300", "RO111", "RO112", "RO113", "RO114", "RO115", "RO116", "RO121", "RO122", "RO123", "RO124", "RO125", "RO126", "RO211", "RO212", "RO213", "RO214", "RO215", "RO216", "RO221", "RO222", "RO223", "RO224", "RO225", "RO226", "RO311", "RO312", "RO313", "RO314", "RO315", "RO316", "RO317", "RO321", "RO322", "RO411", "RO412", "RO413", "RO414", "RO415", "RO421", "RO422", "RO423", "RO424", "RS110", "RS121", "RS122", "RS123", "RS124", "RS125", "RS126", "RS127", "RS211", "RS212", "RS213", "RS214", "RS215", "RS216", "RS217", "RS218", "RS221", "RS222", "RS223", "RS224", "RS225", "RS226", "RS227", "RS228", "RS229", "SE110", "SE121", "SE122", "SE123", "SE124", "SE125", "SE211", "SE212", "SE213", "SE214", "SE221", "SE224", "SE231", "SE232", "SE311", "SE312", "SE313", "SE321", "SE322", "SE331", "SE332", "SI031", "SI032", "SI033", "SI034", "SI035", "SI036", "SI037", "SI038", "SI041", "SI042", "SI043", "SI044", "SK010", "SK021", "SK022", "SK023", "SK031", "SK032", "SK041", "SK042", "TR100", "TR211", "TR212", "TR213", "TR221", "TR222", "TR310", "TR321", "TR322", "TR323", "TR331", "TR332", "TR333", "TR334", "TR411", "XK001", "XK002", "XK003", "XK004", "XK005", "XK006", "XK007")

NUTS.computation <- function(s){
  if(substr(s,1,2) %in% c("EU","EA","EF","CC","OE","G2","G7"))  return(s)
  if(nchar(s)==2 & s %in% NUTS0_codes) return("0")
  if(nchar(s)==3 & s %in% NUTS1_codes) return("1")
  if(nchar(s)==4 & s %in% NUTS2_codes) return("2")
  if(nchar(s)==5 & s %in% NUTS3_codes) return("3")
  return("OTHERS")
}
```


```{r}
for(col in colnames(data)){
  if(is.numeric(data[[col]])) next
  if(col=="TIME_PERIOD"){
    # print(col)
    # print(
    #   paste0("data.start: ",min(data[[col]]),
    #          ", data.end: ",max(data[[col]]),
    #          ", Number of time periods: ",length(unique(data[[col]]))
    #   )
    # )
    
    cat("\nCOLUMNA: TIME_PERIOD \n")
    print(
      data %>%
        group_by(TIME_PERIOD) %>%
        summarise(N.observ=dplyr::n())%>%
        as.matrix() %>%
        noquote()
    )
    next
  }
 if(col=="geo"){
    cat("\nCONTABILIZACIÓN Nº REGIONES NUTS A PARTIR DE LA COLUMNA geo\n")
    print(
      tibble(
        NUTS=sapply(unique(data[[col]]),NUTS.computation)
      ) %>%
        group_by(NUTS) %>%
        summarise(`Number of Regions`=dplyr::n()) %>%
        as.matrix() %>%
        noquote()
    )
    next
 }
  tb <-  data %>%
    left_join(get_eurostat_dic(col)%>%rename(!!col := code_name),
              by=col) %>%
    group_by(!!sym(col),full_name)%>%
    summarise(N.Observ=dplyr::n()) %>%
    relocate(N.Observ,.before = full_name)%>%
    arrange(desc(N.Observ)) %>%
    mutate(full_name=ifelse(nchar(full_name)<41,full_name,paste0(substr(full_name,1,40),"..")))
    
  texto <- paste0("COLUMNA: ",col)
  if(nrow(tb)>50){
    texto <- paste0(texto," (",nrow(tb)," opciones, se imprimen 50)")
    tb <- head(tb,50)
  }
  cat(texto,"\n")
  
  tb %>% 
    as.matrix() %>%
    noquote() %>%
    print()
}

```

### Percentiles de la distribución de tamaños de las series temporales

Observamos que el tamaño de las series temporales varía entre 1 y 29 años, siendo el 90% de las series con más de 22 años.  

```{r}
vars <- colnames(data)[1:(ncol(data)-2)]

data.series <- data %>%
  group_by(across(all_of(vars))) 

data.series.fechas <- data.series %>% 
  summarise(N.fechas=dplyr::n())
```

```{r}
percentiles <- tibble(min=min(data.series.fechas$N.fechas))
percentiles <- percentiles %>% mutate(min=min(data.series.fechas$N.fechas))
percentiles <- percentiles %>% mutate(p10=quantile(data.series.fechas$N.fechas, 0.1))
percentiles <- percentiles %>% mutate(p25=quantile(data.series.fechas$N.fechas, 0.25))
percentiles <- percentiles %>% mutate(p50=quantile(data.series.fechas$N.fechas, 0.50))
percentiles <- percentiles %>% mutate(p75=quantile(data.series.fechas$N.fechas, 0.75))
percentiles <- percentiles %>% mutate(p90=quantile(data.series.fechas$N.fechas, 0.9))
percentiles <- percentiles %>% mutate(max=max(data.series.fechas$N.fechas))

percentiles
```

### Distribución del nº de observaciones por regiones 

Observamos que, tanto para España como para Canarias, el nº de observaciones supera el `p75` de la distribución (1199 > 1159)

```{r}
data.geo <- data %>%
  group_by(geo)%>%
  summarise(N.Observ=dplyr::n())
```

**Percentiles de la distribución del nº de observaciones por regiones**
```{r}
percentiles <- tibble(min=min(data.geo$N.Observ))
percentiles <- percentiles %>% mutate(min=min(data.geo$N.Observ))
percentiles <- percentiles %>% mutate(p10=quantile(data.geo$N.Observ, 0.1))
percentiles <- percentiles %>% mutate(p25=quantile(data.geo$N.Observ, 0.25))
percentiles <- percentiles %>% mutate(p50=quantile(data.geo$N.Observ, 0.50))
percentiles <- percentiles %>% mutate(p75=quantile(data.geo$N.Observ, 0.75))
percentiles <- percentiles %>% mutate(p90=quantile(data.geo$N.Observ, 0.9))
percentiles <- percentiles %>% mutate(max=max(data.geo$N.Observ))

percentiles
```

**Nº de observaciones en España/Canarias**
```{r}
LocalRegionsFullNames <- c("Spain","Canarias","Canarias","El Hierro","Fuerteventura","Gran Canaria",
  "La Gomera","La Palma","Lanzarote","Tenerife")

LocalRegionsCodes <- c("ES","ES7","ES70","ES703","ES704","ES705","ES706","ES707","ES708","ES709")

LocalRegions <- tibble(
  geo=LocalRegionsCodes,
  full_name=LocalRegionsFullNames
)

data.geo %>%
  filter(geo %in% LocalRegionsCodes) %>%
  left_join(LocalRegions,by="geo") %>%
  relocate(full_name,.after = geo)
```


### Combinaciones existentes de las variables categóricas 

El dataset presenta 50 combinaciones únicas de variables categóricas (`freq`, `nace_r2`, `na_item`, `unit`), cumpliendo el criterio mínimo de tener al menos 5 atributos combinados con un número relativamente alto de observaciones (≈8600 observ.).  

```{r}
vars <- colnames(data)[1:(ncol(data)-3)]
vars <- vars[vars != "age"]
vars <- vars[vars != "sex"]

data.combinaciones <- data %>%
  group_by(across(all_of(vars))) 

data.combinaciones %>%
  summarise(N.observ=dplyr::n(),
            init.date=min(TIME_PERIOD),
            end.date=max(TIME_PERIOD)) %>%
  arrange(desc(N.observ)) %>% 
  print(n=50)
```

### Poner las fechas por columnas

Observamos que los datos se mantienen constantes desde el año 2000 hasta el 2023, registrando valores más altos en periodos recientes en comparación con los antiguos. 
  
```{r}
# pasamos las fechas a columnas de la tabla y añadimos algunos datos 
data.fechas <- data %>%
  pivot_wider(names_from = TIME_PERIOD,values_from = values,names_sort = FALSE) %>%
  #relocate(geo) %>% 
  left_join(get_eurostat_dic("geo"), join_by(geo==code_name)) %>%
  relocate(full_name,.after=geo)%>%
  mutate(NUTS=sapply(geo,NUTS.computation)) %>%
  relocate(NUTS)  %>%
  mutate(geo2=substr(geo,1,2)) %>% 
  left_join(get_eurostat_dic("geo")%>%rename(country=full_name),join_by(geo2==code_name)) %>%
  select(-geo2) %>% 
  rename(region=full_name) %>%
  relocate(country,.after = NUTS) %>%
  arrange(NUTS,country,geo)

#data.fechas
```

**Visualización España/Canarias (máximo 60 columnas y 1000 filas por región)**

```{r}
# visualización tabla para España y Canarias 
posRegion <- which(colnames(data.fechas) == "region")
Ncol <- ncol(data.fechas)
posSelect <- 1:Ncol 
if(Ncol>60) posSelect <- unique(c(1:posRegion,(Ncol-60):Ncol))

data.fechas %>%
  select(posSelect) %>% 
  filter(geo %in% LocalRegionsCodes) %>% 
  group_by(geo) %>%
  slice_head(n = 1000) %>%
  ungroup() %>% 
  relocate(region) %>% 
  datatable(
  extensions = 'FixedColumns',
  options = list(
    scrollX = TRUE,  
    scrollY = "400px", 
    paging = FALSE,     
    fixedColumns = list(leftColumns = 1) 
  ),
  class = "stripe hover nowrap",  
  rownames = FALSE  
)
```


## Preparación de los datos
<!-- desarrollo de esta fase -->

### Procesado inicial de los datos

El conjunto de datos original (`nama_10r_2lp10`) presentaba una estructura tidy pero requería una serie de transformaciones para garantizar su calidad y facilitar el análisis exploratorio. Se llevó a cabo un proceso de limpieza y enriquecimiento estructurado en las siguientes fases: 

#### 1. Selección de Atributos y Reducción de Dimensionalidad:  
Se eliminaron variables redundantes o carentes de varianza informativa. Concretamente, se descartó la columna `freq`, dado que presenta un valor único ("A") para todas las observaciones, indicando la periodicidad anual de la serie completa.  

#### 2. Estandarización de la Nomenclatura:  
Para mejorar la legibilidad del código y la manipulación de los datos, se renombraron las variables principales siguiendo un esquema semántico más claro:  

- `nace_r2` $\rightarrow$ `sector`  
- `na_item` $\rightarrow$ `item`  
- `TIME_PERIOD` $\rightarrow$ `year`  

#### 3. Enriquecimiento y Cruce de Datos:  
Se integró información geográfica y descriptiva externa para dotar de contexto a los códigos del dataset original:  

- *Información Geográfica:* Se realizó una unión con el dataset auxiliar (`urostac_real_nuts`). Esto permitió incorporar las columnas `NUTS` (nivel jerárquico) y `full_name` (nombre oficial de la región), claves para el análisis espacial.  
- *Descriptores Sectoriales:* Se generó una variable derivada, `sector_name`, que recodifica los códigos técnicos NACE Rev. 2 (ej. "O-U") en descripciones en lenguaje natural (ej. "Adm. pública, educación y salud"), facilitando la interpretación visual de los gráficos.

#### Estructura Final del Dataset: 
Tras el procesado, el dataset resultante consta de las siguientes variables dimensionadas para el análisis:

- Variables Geográficas: `geo` (Código), `NUTS` (Nivel 0, 1, 2), `full_name` (Etiqueta).  
- Variables Temporales: `year` (Serie 1995-2023).  
- Variables Categóricas: `sector` y `sector_name` (Rama de actividad).  
- Variables Métricas: `item` (Indicador, *promedio anual*: Coste laboral por hora trabajada, Coste laboral por persona empleada, Horas trabajadas), `unit` (Unidad de medida) y `values` (Valor numérico). 
<br>
```{r analisis-data-raw, results=F}
data_raw <- read_csv('data/nama_10r_2lp10.csv') %>% 
    as_tibble()

data_raw
```
```{r analisis-inicial, results=F}
real_names <- read_csv('data/eurostac_real_nuts.csv') %>% 
    as_tibble()


data <- data_raw %>% 
    select(-freq) %>% 
    rename(year = TIME_PERIOD, sector = nace_r2, item = na_item) %>% 
    left_join(real_names, by='geo') %>% 
    select(geo, NUTS, full_name, year, sector, item, unit, values) %>% 
    mutate(sector_name = case_when(
        sector == "TOTAL" ~ "Total actividades",
        sector == "O-U" ~ "Adm. pública, educación y salud",
        sector == "O-Q" ~ "Adm. pública, defensa y educación",
        sector == "B-E" ~ "Industria",
        sector == "K-N" ~ "Finanzas e inmobiliarias",
        sector == "F" ~ "Construcción",
        sector == "M_N" ~ "Profesionales y científicas",
        sector == "A" ~ "Agricultura y pesca",
        sector == "C" ~ "Manufactura",
        sector == "G-J" ~ "Comercio y transporte",
        sector == "R-U" ~ "Artes y otros servicios",
        sector == "G-I" ~ "Comercio y alojamiento",
        sector == "J" ~ "Información y comunicación",
        sector == "K" ~ "Finanzas",
        sector == "L" ~ "Inmobiliarias",
        TRUE ~ "Otro"
        )) %>% 
    relocate(sector_name, .after=sector)
    

data
```
```{r geoj, results=F}
geoj0 <- readRDS("data/geoj0.rds")
geoj1 <- readRDS("data/geoj1.rds")
geoj2 <- readRDS("data/geoj2.rds")

geoj0.tb <- geoj0 %>% as_tibble()
geoj1.tb <- geoj1 %>% as_tibble()
geoj2.tb <- geoj2 %>% as_tibble()
```

### 





Una vez estructurados y limpiados los datos, exploraremos inicialmente las diferencias entre países según los indicadores disponibles en el dataset. Esto nos permitirá identificar patrones generales, contrastar la posición de España frente a otros países y preparar los datos para un análisis más detallado a nivel sectorial y regional.  
<br><br>

En primer lugar, analizamos la evolución del coste laboral por hora trabajada en distintos países. Cada línea representa un país, mostrando tendencias de crecimiento o reducción a lo largo del tiempo, lo que nos permite situar a España en un contexto internacional.
```{r evolucion-coste-hora-paises}
seleccion_paises <- c("Austria", "Belgium", "Denmark", "Finland", "France", "Germany", "Ireland", "Italy", "Luxembourg", "Netherlands", "Spain", "Sweden")

tb_top_evol <- data %>% 
    filter(full_name %in% seleccion_paises, item=="D1_SAL_HW", unit=="EUR", year>=2000) %>%
    group_by(full_name, year) %>% 
    summarise(mean_value = mean(values, na.rm = TRUE)) %>%  # media sobre todos los sectores
    ungroup() %>% 
    select(full_name, year, mean_value) %>% 
    arrange(mean_value)

p <- tb_top_evol %>% mutate(full_name = factor(full_name, levels=(unique(full_name)))) %>% 
    ggplot(aes(x=year,y=mean_value)) +
    geom_line() +
    labs(x="",y="", title="Evolución del coste por hora trabajada") +
    facet_wrap(~full_name) +
    theme(axis.text.x = element_text(angle = 45,hjust=1)) +
    theme(legend.position = "bottom")

ggplotly(p)
```

```{r mapa coroplético}
tb <- geoj0.tb %>% 
    left_join(
        data %>% 
        filter(NUTS==0, item=="D1_SAL_PER", unit=="EUR", year==2022, sector=="TOTAL") %>% 
        na.omit(),
        join_by("NUTS_ID" == "geo")
        )

etiquetas <-paste(
    "<strong> ",tb$full_name ,
    "</strong><br>","Coste laboral por persona empleada",
    ": ",prettyNum(round(tb$values,digits=2), big.mark = " ", scientific = FALSE)
  )  %>%
 lapply(htmltools::HTML)

MapaCoroplético(geoj0, tb$values, etiquetas,"Valor (año 2022)")
```

```{verbatim barras-animado}
tb <- data %>% 
    filter(full_name %in% seleccion_paises, item=="HW_EMP", unit=="HW", year < 2023, year > 2000)

p <- tb %>% 
  ggplot(aes(x=reorder(full_name, values), y=values,fill=full_name)) +
  geom_bar(stat = "identity") + 
  labs(x="", y="Horas trabajadas (promedio anual)") + 
  theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(legend.position = "none")+
  transition_manual(year) +
  labs(title = "Año: {current_frame}")

animate(p,fps = 3,end_pause = 30)
```

```{r scatter}
data_scatter <- data %>%
  # Filtramos solo Países (NUTS 0) y el total de la economía
  filter(full_name %in% seleccion_paises, sector == "TOTAL", year>=2000, year<2023) %>% 
  
  # Nos quedamos con las variables que nos interesan
  filter(item %in% c("HW_EMP", "D1_SAL_HW", "D1_SAL_PER")) %>%
  filter(unit %in% c("HW", "EUR")) %>% # Aseguramos unidades correctas
  
  # Seleccionamos columnas útiles
  select(geo, full_name, year, item, values) %>%
  
  # ¡MAGIA! Convertimos filas en columnas
  pivot_wider(names_from = item, values_from = values)


# 2. Creamos el objeto ggplot
p <- data_scatter %>%
  # Ordenamos por año para asegurar fluidez
  arrange(year) %>% 
  
  ggplot(aes(x = HW_EMP, y = D1_SAL_HW, color = full_name)) +
  
  # PUNTOS (Burbujas)
  geom_point(aes(
    size = D1_SAL_PER,   # Tamaño según coste total anual
    frame = year,        # Esto crea la animación por año
    ids = full_name,     # ¡Importante! Para que la burbuja se mueva suave y no parpadee
    text = paste("País:", full_name, 
                 "<br>Año:", year,
                 "<br>Horas/Año:", round(HW_EMP, 0),
                 "<br>Coste/Hora:", round(D1_SAL_HW, 2), "€") # Tooltip bonito
  ), alpha = 0.7) +
  
  # Escalas y Títulos
  # scale_size(range = c(2, 15)) + # Ajustamos tamaño burbujas min/max
  labs(
    x = "Horas Trabajadas por Empleado (Año)",
    y = "Coste Laboral por Hora (€)",
    title = "Eficiencia vs Presencialismo en Europa",
    color = "País",
    size = ""
  ) +
  
  # Tema limpio
  theme_minimal()

# 3. Renderizamos con Plotly y opciones de animación
ggplotly(p, tooltip = "text") %>% 
  animation_opts(
    frame = 600,       # Duración de cada año (ms)
    transition = 550,  # Duración del movimiento suave
    easing = "linear"
  ) %>%
  layout(title = list(text = "<b>Eficiencia vs Presencialismo:</b> Evolución Europea (2000-2022)"))
```

```{r boxplot-sectores}
p <- data %>%
  # Filtramos países, el indicador de Salario por Persona y aseguramos Euros
  filter(full_name %in% seleccion_paises, item == "D1_SAL_HW", unit == "EUR") %>%
  
  ggplot(aes(x = reorder(full_name,-values), y = values, fill = full_name)) +
  
  geom_boxplot() +
  
  # Rotamos los nombres del eje X para que se lean bien
  theme(axis.text.x = element_text(angle = 45, hjust = 1),legend.position = "none") +
  
  labs(x = "", y = "Coste por empleado (€)")

ggplotly(p)
```

```{r mapa-calor-sectores-eu}
tb <- data %>%
    filter(item == "D1_SAL_HW", unit == "EUR", NUTS == 0, year >= 2018) %>%
    group_by(full_name) %>%
    summarise(mean_value = mean(values, na.rm = TRUE)) %>%
    ungroup()

# Calculamos el valor de Pareto
pareto <- ParetoValue(tb$mean_value, 0.67) # Para quedarnos con 12 justo

countries_pareto <- data %>%
    filter(item == "D1_SAL_HW", unit == "EUR", NUTS == 0, year >= 2018) %>%
    group_by(full_name) %>%
    summarise(mean_value = mean(values, na.rm = TRUE)) %>%
    ungroup() %>% 
    filter(mean_value >= pareto) %>% 
    pull(full_name)

top_countries <- data %>% 
    filter(item=="D1_SAL_HW", unit=="PC_EU27_2020_MEUR_CP", year>=2018, full_name %in% countries_pareto) %>% 
    group_by(full_name, sector_name) %>%
    summarise(mean_value = mean(values, na.rm = TRUE)) %>% 
    ungroup() %>% 
    filter(mean_value>=pareto) %>% 
    filter(sector_name != "Total actividades")
    

p <- top_countries %>% 
    # **AÑADE ESTA LÍNEA:** Excluye la fila donde el nombre del sector sea "Total actividades"

    ggplot(aes(reorder(full_name, -mean_value), sector_name, 
               # Renombramos aquí para el FILL, y también añadimos TEXT para el tooltip
               fill = mean_value, 
               text = paste("País:", full_name,
                            "<br>Sector:", sector_name,
                            "<br>Coste:", round(mean_value, 2), "€/Hora"))) +
    
    # También podemos simplificar estas dos líneas, ya que no vamos a resaltar nada
    # geom_tile(aes(color = sector_name == "Total actividades"), linewidth = 0.75) +
    # scale_color_manual(values = c("TRUE" = "black", "FALSE" = "grey80"), guide = "none") +

    # Versión simplificada SIN borde negro condicional:
    geom_tile() +
    
    scale_fill_gradient(low = "white", high = "steelblue") +
    labs(x = "", y = "", title = "Coste laboral medio por sector y país (2018-23)",fill = "Valor medio") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggplotly(tooltip = "text")
```

```{r top-bottom-horas}
# 1.1. Calcular la media semanal para TODOS los países
tb <- data %>% 
    filter(item == "HW_EMP", unit == "HW", NUTS == 0, year >= 2018) %>% 
    group_by(full_name) %>% 
    summarise(mean_hours = mean(values, na.rm = TRUE)) %>% 
    ungroup() %>% 
    mutate(mean_hours_week = mean_hours / 52.18) %>% # Horas por semana
    select(full_name, mean_hours_week) %>% 
    arrange(desc(mean_hours_week))

# 1.2. Identificar el valor de España
valor_espana <- tb %>%
    filter(full_name == "Spain") %>%
    pull(mean_hours_week)

# 1.3. Seleccionar Top 10, Bottom 10, y asegurar España (si no está ya)
tb_top <- head(tb, 10)
tb_bottom <- tail(tb, 10)

# Aseguramos que España esté incluida si no está en el Top/Bottom (aunque debería estar si son 20+ países)
# Usamos bind_rows y distinct para tener 20 países + España si es extra.
tb_combined <- bind_rows(tb_top, tb_bottom) %>%
    distinct(full_name, .keep_all = TRUE) %>% # Eliminar duplicados si España estaba en el límite
    # Añadimos una columna de color para España y el resto
    mutate(group = if_else(full_name == "Spain", "España", "Resto")) %>%
    # Ordenamos el factor para que el gráfico respete el orden de la tabla (Descendente)
    mutate(full_name = factor(full_name, levels = rev(full_name[order(mean_hours_week)])))


# --- 2. GENERACIÓN DEL GRÁFICO ÚNICO ---

p_final <- tb_combined %>%
    # x es el país (ordenado), y es el valor
    ggplot(aes(x = full_name, y = mean_hours_week, fill = full_name, text = paste("País:", full_name, "<br>Horas:", round(mean_hours_week, 1)))) +
    
    geom_bar(stat = "identity") +
    
    # Añadimos la línea de referencia de España
    geom_hline(yintercept = valor_espana, color = "red", linetype = "dashed", linewidth = 0.8) +
    
    # Invertimos el eje X y el Y, y pasamos las barras a horizontal
    coord_flip() + 
    
    # Texto de referencia para la línea de España
    annotate("text", 
         x = 20,  # <--- Posición vertical de la etiqueta (el país más bajo es 1)
         y = valor_espana + 2, 
         label = "Spain", 
         color = "red", 
         size = 4) +
    
    # Temas y Etiquetas
    labs(x = "", y = "Horas Trabajadas / Semana (Promedio)", 
         title = "Distribución de la Carga Laboral Semanal (Top 10 y Bottom 10") +

    theme(legend.position = "none") # Quitamos la leyenda de los colores

# --- 3. RENDERIZADO INTERACTIVO ---
linea_interactiva <- data.frame(
  x_inicio = 0.5, # El inicio del eje categórico (barra 1)
  x_fin = length(unique(tb_combined$full_name)) + 0.5, # El final del eje categórico
  y_intercep = valor_espana,
  tooltip_linea = paste("Referencia España:", round(valor_espana, 1), "Horas/Semana")
)
p_final <- p_final + 
  geom_segment(data = linea_interactiva, 
               # Mapeamos x/y a los valores y la etiqueta al 'text'
               aes(x = x_inicio, xend = x_fin, 
                   y = y_intercep, yend = y_intercep, 
                   text = tooltip_linea), 
               inherit.aes = FALSE, # ¡Importante! No hereda las aes de los países
               color = "transparent", # Hacemos la línea invisible
               linewidth = 100) # Damos grosor para que sea fácil pasar el ratón

# Usamos ggplotly y especificamos que use el texto personalizado para los tooltips
ggplotly(p_final, tooltip = "text")
```

```{r evolucion-sectores-españa}
  data_vars <- data %>%
    filter(
      item == "D1_SAL_HW",
      unit == "EUR",
      geo == "ES",
      sector != "TOTAL"
    ) %>%
    arrange(year)

  # 4. CREACIÓN DEL GRÁFICO
  #    Base: Las regiones variables
  hc <- hchart(
  data_vars, 
  type = "line",
  # CORRECCIÓN CLAVE AQUÍ ABAJO:
  # Cambiamos group = full_name por group = sector_name (o nace_r2)
  # para que dibuje una línea por cada sector, no una sola línea loca.
  hcaes(x = year, y = values, group = sector_name), 
  marker = list(enabled = TRUE, symbol = "circle", radius = 3)
)
  
hc
```

```{r mapa-calor-sectores-CCAA}
top_comunidades_ES <- data %>% 
    filter(item=="D1_SAL_HW", unit=="EUR", year>=2018, substr(geo, 1, 2) == "ES" & NUTS==2) %>% 
    group_by(full_name, sector_name) %>%
    summarise(mean_value = mean(values, na.rm = TRUE)) %>% 
    ungroup()
    
p <- top_comunidades_ES %>% 
    # **AÑADE ESTA LÍNEA:** Excluye la fila donde el nombre del sector sea "Total actividades"

    ggplot(aes(reorder(full_name, -mean_value), sector_name, 
               # Renombramos aquí para el FILL, y también añadimos TEXT para el tooltip
               fill = mean_value, 
               text = paste("Comunidad_:", full_name,
                            "<br>Sector:", sector_name,
                            "<br>Coste:", round(mean_value, 2), "€/Hora"))) +
    
    # También podemos simplificar estas dos líneas, ya que no vamos a resaltar nada
    # geom_tile(aes(color = sector_name == "Total actividades"), linewidth = 0.75) +
    # scale_color_manual(values = c("TRUE" = "black", "FALSE" = "grey80"), guide = "none") +

    # Versión simplificada SIN borde negro condicional:
    geom_tile() +
    
    scale_fill_gradient(low = "white", high = "steelblue") +
    labs(x = "", y = "", title = "Coste laboral medio por sector y CCAA (2018-23)",fill = "Valor medio") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggplotly(tooltip = "text")
```

```{r mapa-coropletico-costeES}
geoj_esp <- geoj2[substr(geoj2$NUTS_ID, 1, 2) == "ES", ]
geoj_esp.tb <- geoj_esp %>% as_tibble()

tb <- geoj_esp.tb %>% 
    left_join(
        data %>% 
        filter(substr(geo, 1, 2) == "ES" & NUTS == 2, item=="D1_SAL_PER", unit=="EUR", year==2023, sector=="TOTAL") %>% 
        na.omit(),
        join_by("NUTS_ID" == "geo")
        )

etiquetas <-paste(
    "<strong> ",tb$full_name ,
    "</strong><br>","Coste laboral por persona empleada",
    ": ",prettyNum(round(tb$values,digits=2), big.mark = " ", scientific = FALSE)
  )  %>%
 lapply(htmltools::HTML)

MapaCoropléticoES(geoj_esp, tb$values, etiquetas,"Valor (año 2023)")
```

```{verbatim horas-trabajdas}
tb <- data %>% 
    filter(full_name %in% seleccion_paises, item=="HW_EMP", unit=="HW", year==2022)

p <- tb %>% 
  ggplot(aes(x=reorder(full_name, values), y=values,fill=full_name)) +
  geom_bar(stat = "identity") + 
  labs(x="", y="Horas trabajadas (promedio anual)") + 
  theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme(legend.position = "none")

ggplotly(p)
```

```{r dubmbell-plot}
max_year <- max(data$year, na.rm = TRUE)

df_dumbbell <- data %>%
  filter(
    full_name %in% c("Spain", "Canarias"),
    item == "D1_SAL_HW",
    unit == "EUR",
    year == max_year, # Snapshot del último año
    sector != "TOTAL" 
  ) %>%
  select(sector_name, full_name, values) %>%
  drop_na()

# 2. Generación del gráfico de mancuernas (Dumbbell Plot)
p_dumbbell <- df_dumbbell %>%
  
  mutate(sector_name = fct_reorder(sector_name, values, .fun = mean, na.rm = TRUE)) %>%
  
  # 2.1. Mapeamos el color general
  ggplot(aes(x = values, y = sector_name, color = full_name)) +
  
  # Línea que conecta los puntos (la 'mancuerna')
  geom_line(aes(group = sector_name), color = "grey", linewidth = 1) +
  
  # Puntos (las 'pesas') - Aquí metemos el tooltip y ajustamos el tamaño
  geom_point(
    # AÑADIDO: Tooltip SÓLO en los puntos
    aes(text = paste("Región:", full_name, 
                     "<br>Sector:", sector_name,
                     "<br>Coste/Hora:", round(values, 2), "€")), 
    size = 2.5 # AJUSTE: Hacemos los puntos más pequeños (antes 4)
  ) +
  
  # Configuración de color y leyenda
  scale_color_manual(values = c("Canarias" = "red", "Spain" = "#1F77B4"), name = "Región") +
  
  # Etiquetas y Títulos
  labs(
    title = paste("Brecha Sectorial del Coste por Hora: España vs. Canarias (", max_year, ")"),
    x = "Coste Laboral por Hora (€)",
    y = "Sector Laboral"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")

# 3. Renderizado interactivo
ggplotly(p_dumbbell, tooltip = "text")
```

```{r donut-sectores-es23}
# --- 1. PREPARACIÓN Y FILTRADO DE DATOS ---

tb_plotly <- data %>%
  filter(
    geo == "ES", 
    item == "D1_SAL_HW", 
    unit == "EUR", 
    year == 2023, 
    sector != "TOTAL"
  ) %>%
  group_by(sector_name) %>%
  # Calculamos la suma total del Coste por Hora por sector para el porcentaje
  summarise(total_value = sum(values, na.rm = TRUE)) %>% 
  ungroup() %>%
  drop_na()

# --- 2. GENERACIÓN DEL GRÁFICO DINÁMICO (PLOTLY DONUT) ---

p_donut_dinamico <- tb_plotly %>%
  plotly::plot_ly(
    labels = ~sector_name,
    values = ~total_value,
    textposition = 'inside',
    # Configuración de texto y orientación (como en tu ejemplo)
    textinfo = 'label+percent',
    insidetextorientation = 'radial',
    hoverinfo = 'label+percent+value' # Tooltip personalizado
  ) %>%
  
  # Añadimos el agujero y quitamos la leyenda para dejar el gráfico limpio
  add_pie(hole = 0.3) %>%
  
  layout(
    title = "Distribución del Coste Laboral por Sector (España, 2023)",
    showlegend = FALSE, # Quitamos la leyenda
    # Aseguramos que el gráfico se muestre como círculo
    xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
    yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE)
  )

ggplotly(p_donut_dinamico)
```

```{r variacion-salarios}
df_variation <- data %>%
  filter(full_name == "Spain", NUTS == 0, sector == "TOTAL", item == "D1_SAL_HW", unit == "EUR") %>%
  arrange(year) %>%
  group_by(full_name) %>%
  # Cálculo de la variación porcentual interanual (Perfecto como lo tienes)
  mutate(variation_pct = (values / lag(values) - 1) * 100) %>%
  ungroup() %>%
  drop_na() # Quitamos el NA del primer año

# --- 2. GENERACIÓN DEL GRÁFICO INTERACTIVO (PLOTLY) ---
p_variation_plotly <- df_variation %>%
  plotly::plot_ly(
    x = ~year, 
    y = ~variation_pct, 
    type = 'scatter', 
    mode = 'lines+markers',
    name = 'Variación % Anual',
    line = list(color = '#1F77B4') # Color principal
  ) %>%
  
  # Añadir línea de referencia en cero (para señalar picos y valles)
  add_trace(
    y = 0, 
    x = ~year,
    mode = 'lines',
    line = list(color = 'red', dash = 'dash'),
    name = 'Referencia 0%'
  ) %>%
  
  # Configuración y Layout (Limpieza de ejes)
  layout(
    title = "Variación Anual % del Coste Laboral por Hora en España",
    xaxis = list(title = "Año", tickmode = 'linear', dtick = 5), # Muestra años cada 5 para limpiar el eje
    yaxis = list(title = "Variación Porcentual (%)"),
    showlegend = TRUE 
  )

ggplotly(p_variation_plotly)
```

```{r top3sectores-canarias}
# Filtrado de Canarias y ordenamiento
tb <- data %>% 
    filter(geo == "ES7", item == "D1_SAL_HW", unit == "EUR", year == 2023, sector != "TOTAL") %>% 
    arrange(values)

top <- tb %>% tail(3)
bottom <- tb %>% head(3)

# Valor de referencia de España (media nacional)
valor_referencia <- data %>% 
    filter(geo == "ES", item == "D1_SAL_HW", unit == "EUR", year == 2023, sector == "TOTAL") %>%
    pull(values)

# 2. COMBINACIÓN Y CLASIFICACIÓN DE SECTORES
df_plot <- bind_rows(
    top %>% mutate(Sector_Type = "Top 3 (Mejor Remunerado)"),
    bottom %>% mutate(Sector_Type = "Bottom 3 (Peor Remunerado)")
)

# 3. GENERACIÓN DEL GRÁFICO (Barra horizontal con referencia)
p_top_bottom <- df_plot %>%
    ggplot(aes(x = reorder(sector_name, values), y = values, fill = Sector_Type)) +
    
    # Barras (coord_flip requiere hjust = -0.1 para texto fuera)
    geom_bar(
      stat = "identity", 
      color = "black",
      aes(text = paste("Sector:", sector_name, 
                       "<br>Coste/Hora:", round(values, 2), "€"))
    ) +
    
    # Línea de referencia de España
    geom_hline(yintercept = valor_referencia, color = "red", linetype = "dashed", linewidth = 1) +
    
    # Anotación para la línea de España (colocada en el inicio del eje X)
    annotate("text", 
             x = 0.5, y = valor_referencia + 2, 
             label = "Media Nacional", 
             color = "red", hjust = -0.1, vjust = -1, size = 3.7) +
    
    # Temas y Labels
    scale_fill_manual(values = c("Top 3 (Mejor Remunerado)" = "#1F77B4", "Bottom 3 (Peor Remunerado)" = "#FF7F0E")) +
    labs(title = paste("Contraste Salarial Sectorial en Canarias (", 2023, ")"),
         subtitle = "Comparación Top 3 y Bottom 3 vs. Media Nacional de Coste por Hora",
         y = "Coste Laboral por Hora (€)",
         x = "",
         fill = "Remuneración del sector") +
    theme(legend.position = "bottom", axis.text.x = element_text(angle = 45, hjust = 1))

ggplotly(p_top_bottom, tooltip = "text")


    
```

```{r boxplot-sectores-NUTS1}
p <- data %>%
  # Filtramos países, el indicador de Salario por Persona y aseguramos Euros
  filter(substr(geo, 1, 2) == "ES" & NUTS == 1, item == "D1_SAL_HW", unit == "EUR") %>%
  
  ggplot(aes(x = reorder(full_name,-values), y = values, fill = full_name)) +
  
  geom_boxplot() +
  
  # Rotamos los nombres del eje X para que se lean bien
  theme(axis.text.x = element_text(angle = 45, hjust = 1),legend.position = "none") +
  
  labs(x = "", y = "Coste por hora trabajada (€)")

ggplotly(p)
```

```{r sectores-wrapped-ESIC}
# --- 1. PREPARACIÓN DE DATOS BASE ---
df_facet <- data %>%
  filter(
    # Filtramos por España y Canarias (NUTS 0 y NUTS 2)
    (full_name %in% c("Spain") & NUTS == 0) | 
    (full_name %in% c("Canarias") & NUTS == 2),
    item == "D1_SAL_HW",
    unit == "EUR",
    # sector != "TOTAL" # Excluimos el total para ver los sectores individuales
  ) %>%
  # Renombrar Spain para que la leyenda se vea mejor
  mutate(full_name = if_else(full_name == "Spain", "España", full_name)) %>%
  drop_na(values)


# --- 2. GENERACIÓN DEL GRÁFICO (FACET WRAP) ---
p_facet_time_series <- df_facet %>%
  ggplot(aes(x = year, y = values, color = full_name, group = full_name)) +
  
  geom_line(linewidth = 0.5,
            aes(text = paste("Región:", full_name,
                     "<br>Sector:", sector_name,
                     "<br>Año:", year,
                     "<br>Coste/Hora:", round(values, 2), "€"))) +
  
  # Dividir el gráfico por sector: scales="free_y" ajusta el eje Y a cada sector
  facet_wrap(~sector_name, scales = "free_y") + 
  
  # Labels
  labs(
    title = "Evolución Sectorial del Coste Laboral por Hora: España vs. Canarias",
    subtitle = paste0("Periodo: ", min(df_facet$year), " - ", max(df_facet$year)),
    y = "Coste por Hora (€)",
    x = "Año",
    color = "Región"
  ) +
  
  # Temas y Estilo
  scale_color_manual(values = c("Canarias" = "red", "España" = "#1F77B4")) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 8),
    legend.position = "bottom",
  )

ggplotly(p_facet_time_series, tooltip = "text")
```

```{r mapa-coropletico-horasES}
geoj_esp <- geoj2[substr(geoj2$NUTS_ID, 1, 2) == "ES", ]
geoj_esp.tb <- geoj_esp %>% as_tibble()

tb <- geoj_esp.tb %>% 
    left_join(
        data %>% 
        filter(substr(geo, 1, 2) == "ES" & NUTS == 2, item=="HW_EMP", unit=="HW", year==2023, sector=="TOTAL") %>% 
        na.omit(),
        join_by("NUTS_ID" == "geo")
        )

etiquetas <-paste(
    "<strong> ",tb$full_name ,
    "</strong><br>","Horas trabajadas anuales",
    ": ",prettyNum(round(tb$values,digits=2), big.mark = " ", scientific = FALSE)
  )  %>%
 lapply(htmltools::HTML)

MapaCoropléticoES(geoj_esp, tb$values, etiquetas,"Valor (año 2023)")
```


A continuación, examinamos los diez países con mayor y menor carga laboral promedio por empleado. Los valores reflejan horas efectivas trabajadas por semana, y la línea roja indica la posición de España para contextualizar su situación frente a estos países.
```{verbatim top-bottom-carga-laboral, fig.width=8, fig.height=5.5}
tb <- data %>% 
    filter(item=="HW_EMP", unit=="HW", NUTS==0, year>=2018) %>% 
    group_by(full_name) %>% 
    summarise(mean_hours=mean(values)) %>% 
    ungroup() %>% 
    mutate(mean_hours_week = mean_hours / 52.18) %>%  # Para obtener horas por semana (365.25 / 7)
    select(full_name, mean_hours_week) %>% 
    arrange(desc(mean_hours_week)) 
    
tb_top <- head(tb, 10)
tb_bottom <- tail(tb, 10)

valor_españa <- tb %>%
  filter(full_name == "Spain") %>%
  pull(mean_hours_week)

tb_top %>% mutate(full_name = factor(full_name, levels=(unique(full_name)))) %>% 
    ggplot(aes(x=full_name, y=mean_hours_week, fill=full_name)) +
    geom_bar(stat = "identity") +
    geom_hline(yintercept = valor_españa, color = "red", linetype = "dashed", linewidth = 0.8) + # Valor de España como referencia
    geom_text(aes(label = round(mean_hours_week, 1)), vjust = -0.1, size = 3) +
    labs(x="",y="Horas / Semana", title = "Países con mayor carga laboral media semanal por empleado") +
    theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1)) + # Quita la leyenda y pone los nombres 45º
    annotate("text", x = length(unique(tb_bottom$full_name)) + 1.1, 
             y = valor_españa, label = "Spain", color = "red", vjust = -0.5, hjust = 1.1, size = 4)


tb_bottom %>% mutate(full_name = factor(full_name, levels=(unique(full_name)))) %>% 
    ggplot(aes(x=full_name, y=mean_hours_week, fill=full_name)) +
    geom_bar(stat = "identity") +
    geom_hline(yintercept = valor_españa, color = "red", linetype = "dashed", linewidth = 0.8) + # Valor de España como referencia
    geom_text(aes(label = round(mean_hours_week, 1)), vjust = -0.1, size = 3) +
    labs(x="",y="Horas / Semana", title = "Países con menor carga laboral media semanal por empleado") +
    theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1)) + # Quita la leyenda y pone los nombres 45º
    annotate("text", x = length(unique(tb_bottom$full_name)) + 0.6, 
             y = valor_españa, label = "Spain", color = "red", vjust = -0.5, hjust = 1.1, size = 4)
    
```

Luego, mostramos los países con mayor coste laboral por hora trabajada. Se incluyen los datos más recientes disponibles (2018-2023).
```{verbatim mayor-coste-laboral-hora}
# Modificamos la tabla
tb <- data %>%
    filter(item == "D1_SAL_HW", unit == "EUR", NUTS == 0, year >= 2018) %>%
    group_by(full_name) %>%
    summarise(mean_value = mean(values, na.rm = TRUE)) %>%
    ungroup()

# Calculamos el valor de Pareto
pareto <- ParetoValue(tb$mean_value, 0.67) # Para quedarnos con 12 justo

tb_top <- tb %>%
    filter(mean_value >= pareto) %>% 
    arrange(mean_value)

# Graficamos
tb_top %>% mutate(full_name = factor(full_name, levels=(unique(full_name)))) %>% 
    ggplot(aes(x=full_name, y=mean_value, fill=full_name)) +
    geom_bar(stat = "identity") +
    geom_text(aes(label = round(mean_value, 1)), hjust = -0.2) +
    labs(x="",y="Precio por hora trabajada (EUR)", title = "Paises con un mayor coste laboral por hora trabajada") + 
    coord_flip() + # Cambia los ejes x <-> y
    theme(legend.position = "none") + # Quita la leyenda
    ylim(0, max(tb_top$mean_value) + 0.6)  # deja espacio a la derecha para el texto
```

Para complementar la visión internacional, se incluye un mapa de calor que compara el coste medio por sector entre distintos países. Los colores más intensos indican costes más altos, facilitando la identificación de sectores más costosos en cada país. Usaremos el indicador `PC_EU27_2020_MEUR_CP`, que muestra el porcentaje que representa cada país respecto al total de la Unión Europea (UE27) en precios corrientes. Usaremos los datos más recientes (2018-2023).
```{verbatim heatmap-sector-paises, fig.width=10}
countries_pareto <- data %>%
    filter(item == "D1_SAL_HW", unit == "EUR", NUTS == 0, year >= 2018) %>%
    group_by(full_name) %>%
    summarise(mean_value = mean(values, na.rm = TRUE)) %>%
    ungroup() %>% 
    filter(mean_value >= pareto) %>% 
    pull(full_name)

top_countries <- data %>% 
    filter(item=="D1_SAL_HW", unit=="PC_EU27_2020_MEUR_CP", year>=2018, full_name %in% countries_pareto) %>% 
    group_by(full_name, sector_name) %>%
    summarise(mean_value = mean(values, na.rm = TRUE)) %>% 
    ungroup() %>% 
    filter(mean_value>=pareto)
    

top_countries %>% rename(`Valor medio` = mean_value) %>% 
    ggplot(aes(reorder(full_name, -`Valor medio`),sector_name,fill=`Valor medio`)) +
    geom_tile(aes(color = sector_name == "Total actividades"), linewidth = 0.75) +
    scale_color_manual(values = c("TRUE" = "black", "FALSE" = "grey80"), guide = "none") +
    scale_fill_gradient(low = "white", high = "steelblue") +
    geom_text(aes(label = round(`Valor medio`,1)), color = "black") +
    labs(x="",y="", title="Coste laboral medio por sector y país") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Vamos a hacer lo mismo ahora para las comunidades autónomas de España, usando el indicador `EUR`, que representa el valor del precio medio por hora trabajada expresado directamente en euros. Usaremos también los datos más recientes (2018-2023).
```{verbatim heatmap-sector-comunidades, fig.width=12.5, fig.height=7.5}
top_comunidades_ES <- data %>% 
    filter(item=="D1_SAL_HW", unit=="EUR", year>=2018, substr(geo, 1, 2) == "ES",NUTS==2, full_name!="Spain") %>% 
    group_by(full_name, sector_name) %>%
    summarise(mean_value = mean(values, na.rm = TRUE)) %>% 
    ungroup()
    

top_comunidades_ES %>% rename(`Valor medio` = mean_value) %>% 
    ggplot(aes(reorder(full_name, -`Valor medio`),sector_name,fill=`Valor medio`)) +
    geom_tile(aes(color = sector_name == "Total actividades"), linewidth = 0.75) +
    scale_color_manual(values = c("TRUE" = "black", "FALSE" = "grey80"), guide = "none") +
    scale_fill_gradient(low = "white", high = "steelblue") +
    geom_text(aes(label = round(`Valor medio`,1)), color = "black") +
    labs(x="",y="", title="Coste laboral medio por sector y comunidad autónoma (España)") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

A continuación, comparamos el coste medio por hora trabajada según el sector laboral en España. Este gráfico permite identificar los sectores con salarios más altos y más bajos por hora, facilitando el análisis comparativo entre ellos.
```{verbatim precio-hora-por-sector, fig.width=10}
tb <- data %>% 
    filter(year>=2018, item=="D1_SAL_HW", unit=="EUR") %>% 
    group_by(sector_name) %>% 
    summarise(mean_value = mean(values)) %>% 
    ungroup() %>% 
    arrange(desc(mean_value))

# Sacamos el valor total de la tabla, y lo guardamos para poder compararlo
total <- tb %>% 
    filter(sector_name=="Total actividades") %>% 
    pull(mean_value)

tb <- tb %>% 
    filter(sector_name!="Total actividades")


tb %>% ggplot(aes(x = reorder(sector_name, mean_value), 
    y = mean_value, 
    fill = sector_name)) +
    geom_bar(stat = "identity") +
    coord_flip() +
    labs(
        x = "Sector económico (NACE Rev.2)",
        y = "Precio por hora trabajada (EUR)",
        title = "Precio medio por hora trabajada según el sector laboral",
        fill = "Sector") +
    geom_text(aes(label = round(mean_value, 1)), hjust = -0.2) +
    theme(legend.position = "none")    
```

Seguido de esto, se muestra la participación de cada sector en el coste laboral medio total de España durante 2023 mediante un gráfico por secciones. Esto permite analizar qué sectores contribuyen más o menos al coste global.
```{verbatim coste-sector-espana-2023, fig.height=5, fig.width=7.5}
tb <- data %>%
    filter(geo == "ES", item == "D1_SAL_HW", unit == "EUR", year == 2023, sector!="TOTAL") %>%
    group_by(sector_name) %>%
    summarise(mean_value = mean(values, na.rm = TRUE)) %>%
    mutate(perc = mean_value / sum(mean_value) * 100, label = paste0(round(perc, 1), "%"))

tb %>% ggplot(aes(x = 2, y = perc, fill = reorder(sector_name, perc))) +
    geom_col(width = 1, color = "white") +
    coord_polar("y", start = pi/2) + # Para rotar el circulo
    xlim(0.7, 2.5) + # El radio de donde se hace el gráfico
    geom_text(aes(label = label), position = position_stack(vjust = 0.5), size = 3) +
    labs(title = "Coste laboral medio por sector (España, 2023)", fill = "Sector", x="", y="") +
    scale_y_continuous(labels = NULL) +  # quitar los números del eje
    theme(axis.text.y = element_blank())     # quita los números del eje
```

Para entender la variabilidad interna, se incluye un boxplot del coste laboral medio por persona empleada en los países de Europa analizados previamente. Este gráfico permite observar los valores típicos, la dispersión y posibles valores atípicos dentro de los distintos países.
```{verbatim boxplot-coste-persona}
seleccion_paises <- c("Austria", "Belgium", "Denmark", "Finland", "France", "Germany", "Ireland", "Italy", "Luxembourg", "Netherlands", "Spain", "Sweden")

tb <- data %>% 
    filter(NUTS == 0, item == "D1_SAL_PER", unit == "EUR", sector == "TOTAL", full_name %in% seleccion_paises) %>% 
    select(full_name, year, values)

tb %>%
    ggplot(aes(x=reorder(full_name, -values),y=values,fill=full_name)) +
    geom_boxplot() +
    labs(x="", y="Coste anual (EUR)", title = "Coste laboral medio por persona empleada") +
    theme(legend.position = "none", axis.text.x = element_text(angle = 45, hjust = 1))
    
```

Finalmente, se presenta un gráfico de dispersión comparando el coste laboral medio entre España y Canarias. Cada punto representa un sector o grupo de empleados, permitiendo visualizar diferencias y correlaciones entre ambos territorios.
```{verbatim dispersion-espana-canarias}
tb <- data %>%  
    filter(geo %in% c("ES", "ES7"), item == "D1_SAL_PER", unit == "EUR", sector == "TOTAL") %>% 
    select(full_name, year, values) %>% 
    pivot_wider(names_from = full_name, values_from = values)

tb %>% 
    ggplot(aes(x=Canarias,y=Spain)) +
    geom_point() +
    geom_smooth(method = lm, se = FALSE) +
    labs(title="Gráfico de dispersión coste laboral anual - ES vs IC", y="España")
    
```


## Modelado
<!-- desarrollo de esta fase -->
```{r matriz-dispersion}
data %>% 
  filter(item=="D1_SAL_HW", unit=="EUR", substr(geo, 1, 2) == "ES" & NUTS == 2) %>%  
  group_by(full_name, sector_name) %>%
  summarise(values=mean(values)) %>%
  ungroup() %>%
  pivot_wider(names_from = sector_name, values_from = values) %>%
  na.omit() %>% 
  select(-full_name) %>% 
  cor(use = "complete.obs") %>% 
  plot_correlation(show_values = TRUE) 
```
```{r regresion-lineal}
# --- 1. PREPARACIÓN Y PIVOTADO DE DATOS ---

# Filtramos los dos indicadores de interés y nos aseguramos de usar las unidades correctas
tb_comparacion_estatica <- data %>%
  filter(
    item %in% c("D1_SAL_HW", "HW_EMP"),
    unit %in% c("EUR", "HW"),
    NUTS==0
  ) %>%
  
  # Seleccionamos las columnas clave para el pivote
  select(full_name, year, sector_name, item, values) %>%
  
  # Transformamos a formato ancho para que D1_SAL_HW (Eje Y) y HW_EMP (Eje X) sean columnas
  pivot_wider(
    names_from = item, 
    values_from = values,
    values_fn = mean # Usamos mean por si hay duplicados menores en el dataset
  ) %>%
  
  # Limpiamos los NAs que impiden la comparación
  drop_na(D1_SAL_HW, HW_EMP)


# --- 2. GENERACIÓN DEL DIAGRAMA DE DISPERSIÓN ESTÁTICO ---

# --- 2. GENERACIÓN DEL DIAGRAMA DE DISPERSIÓN ESTÁTICO CORREGIDO ---

p_dispersion_estatica <- tb_comparacion_estatica %>%
  
  # 1. Quitamos la estética 'text' de aquí para que geom_smooth NO la herede
  ggplot(aes(x = HW_EMP, y = D1_SAL_HW, color = full_name)) + 
  
  # 2. Añadimos la estética 'text' SÓLO a geom_point
  geom_point(aes(text = paste("País:", full_name,
                             "<br>Año:", year,
                             "<br>Horas Trabajadas:", round(HW_EMP, 0),
                             "<br>Coste por Hora:", round(D1_SAL_HW, 2), "€")),
             alpha = 0.5) +
  
  # 3. geom_smooth ahora hereda SOLO x e y, por lo que se renderiza correctamente
  geom_smooth(method = lm, se = FALSE, color = "#333333", linewidth = 0.8) +
  
  # Etiquetas y Títulos
  labs(
    x = "Horas Trabajadas por Empleado (HW)", 
    y = "Coste Laboral por Hora (€)",
    title = "Relación entre Horas Trabajadas y Coste por Hora (1995-2023)",
    subtitle = "Cada punto representa una observación (Región/Sector/Año)"
  ) +
  
  theme_minimal() +
  theme(legend.position = "none")

# Visualizar el gráfico. Plotly encontrará el canal 'text' en los puntos.
ggplotly(p_dispersion_estatica, tooltip = "text")
```






En esta parte del análisis, nos centramos en estudiar la evolución temporal de las horas trabajadas en España y su remuneración por hora, para posteriormente aplicar modelos de predicción ARIMA que permitan estimar su posible comportamiento en los próximos años.  

### Análisis de las horas trabajadas
Comenzamos observando la evolución de las horas trabajadas en España durante el periodo disponible. Destaca la caída registrada en 2020, resultado del impacto de la pandemia y de la reducción de las horas efectivas trabajadas por los ERTE y las restricciones laborales.
```{r evolucion-horas-españa-data, results=F}
horas.españa <- data %>% 
    filter(geo == "ES", item=="HW_EMP", unit=="HW") %>% 
    select(year, values) %>% 
    as_tsibble(index = year) %>% 
    fill_gaps()

horas.españa
```
```{r evolucion-horas-españa}
horas.españa %>% 
    autoplot() +
    labs(title = "Evolución de las horas trabajadas anualmente en España", x="Año", y="Horas")
```

Para ajustar el modelo ARIMA de horas trabajadas, omitimos el año 2020, ya que la anomalía causada por la pandemia distorsionaría los parámetros del modelo.
```{r evolucion-horas-españa-covid-data, results=FALSE}
horas.españa.omit.covid <- horas.españa %>% 
    filter(year!=2020) %>%
    fill_gaps()


horas.españa.omit.covid
```

A continuación, comparamos la evolución de España y Canarias, donde se aprecia que las horas trabajadas en Canarias son superiores a la media nacional, reflejando la particularidad de su mercado laboral y la mayor presencia de sectores con jornadas más largas.
```{r evolucion-horas-españa-canarias}
comparacion.ES_IC.horas <- data %>% 
    filter(geo %in% c("ES", "ES7"), item=="HW_EMP", unit=="HW") %>% 
    select(year, geo, values) %>% 
    mutate(geo = ifelse(geo == "ES7", "Canarias", "España"),
             # Para que salga España primero como en el de abajo y mantener coherencia 
           geo = factor(geo, levels = c("España", "Canarias"))) %>% 
    as_tsibble(index = year, key = geo) %>% 
    fill_gaps()


# CAMBIAR EL ORDEN EN EL QUE SE MUESTRA, PRIMERO ES COMO EN EL DE ABAJO
comparacion.ES_IC.horas %>% rename(Región = geo) %>% 
    autoplot() +
    labs(title = "Horas anuales - ES vs IC", x="Año",y="Horas") +
    scale_color_manual(values = c("Canarias" = "steelblue", "España" = "red"))
```

España mantiene horas trabajadas superiores a la media europea, situándose en un nivel más alto en comparación con otros países de la UE.
```{r evolucion-horas-españa-europa}
comparacion.ES_UE.horas <- data %>% 
    filter(geo %in% c("ES", "EU27_2020"), item=="HW_EMP", unit=="HW") %>% 
    select(year, geo, values) %>% 
    mutate(geo = ifelse(geo == "EU27_2020", "Unión Europea", "España")) %>% 
    as_tsibble(index = year, key = geo) %>% 
    fill_gaps()

comparacion.ES_UE.horas %>% rename(Región = geo) %>% 
    autoplot() +
    labs(title = "Horas anuales - ES vs UE", x = "Año", y = "Horas") +
    scale_color_manual(values = c("Unión Europea" = "green", "España" = "red"))
```

Con el modelo ARIMA aplicado a las horas trabajadas, se estima la evolución para los próximos cinco años. El modelo se ha ajustado omitiendo 2020, dado el impacto anómalo de la pandemia, y proyecta una ligera continuidad en la tendencia a la baja, aunque con cierta variabilidad en los valores futuros.
```{r evolucion-horas-españa-arima, results = F}
horas.españa.omit.covid.arima <- horas.españa.omit.covid %>% 
    model(ARIMA(values))
```
```{r descomposicion-horas-españa}
horas.españa.STL <- horas.españa %>% 
    model(STL(values,robust = TRUE)) %>% 
    components()

p <- horas.españa.STL %>% 
    autoplot() +
    labs(x="Año")

ggplotly(p)
```

```{r evolucion-horas-españa-prediccion}
horas.españa.omit.covid.prediccion <- horas.españa.omit.covid.arima %>%
     forecast(h="5 years")

GraficoDinamicoArima95CI(horas.españa, "year", "values", horas.españa.omit.covid.prediccion, "Título")
```

```{r real-vs-arima-horas}
# Generamos el data frame con los valores reales y ajustados del modelo
ajuste_horas <- horas.españa.omit.covid.arima %>% 
  augment()  # añade columnas .fitted y .resid

# Gráfico de comparación entre los valores reales y el ajuste del modelo ARIMA
ajuste_horas %>%
  ggplot(aes(x = year)) +
  geom_line(aes(y = values, colour = "Real")) +
  geom_line(aes(y = .fitted, colour = "Ajuste ARIMA"), linetype = "dashed") +
  labs(
    title = "Calidad ajuste del modelo ARIMA - Horas anuales ES",
    x = "Año", y = "Horas"
  ) +
  scale_colour_manual(values = c("Real" = "black", "Ajuste ARIMA" = "red")) +
  theme(legend.title = element_blank())
```


### Análisis de la remuneración por hora
Pasamos después al análisis de la remuneración por hora trabajada, que muestra una trayectoria más estable y creciente en el tiempo, reflejando una recuperación progresiva tras la crisis sanitaria.
```{verbatim evolucion-remun-españa-data, results = F}
remun.españa <- data %>% 
    filter(geo == "ES", item=="D1_SAL_HW", unit=="EUR", sector=="TOTAL") %>% 
    select(year, values) %>% 
    as_tsibble(index = year) %>% 
    fill_gaps()

remun.españa
```
```{verbatim evolucion-remun-españa}
remun.españa %>% 
    autoplot() +
    labs(title = "Evolución del coste laboral por hora trabajada en España", x="Año", y="EUR / Hora")
```

En la comparación entre España y Canarias, se observan diferencias consistentes: las islas mantienen remuneraciones inferiores a la media nacional, influenciadas por su estructura productiva y los sectores predominantes.
```{verbatim evolucion-remun-españa-canarias}
comparacion.ES_IC.remun <- data %>% 
    filter(geo %in% c("ES", "ES7"), item=="D1_SAL_HW", unit=="EUR", sector=="TOTAL") %>% 
    select(year, geo, values) %>% 
    mutate(geo = ifelse(geo == "ES7", "Canarias", "España"),
             # Para que salga España primero como en el de abajo y mantener coherencia 
           geo = factor(geo, levels = c("España", "Canarias"))) %>% 
    as_tsibble(index = year, key = geo) %>% 
    fill_gaps()


# CAMBIAR EL ORDEN EN EL QUE SE MUESTRA, PRIMERO ES COMO EN EL DE ABAJO
comparacion.ES_IC.remun %>% rename(Región = geo) %>% 
    autoplot() +
    labs(title = "Coste laboral por hora trabajada - ES vs IC", x="Año",y="EUR / Hora") +
    scale_color_manual(values = c("Canarias" = "steelblue", "España" = "red"))
```

En el contexto europeo, la remuneración media por hora en España es ligeramente inferior a la media de la UE, reflejando diferencias en productividad y estructura económica.
```{verbatim evolucion-remun-españa-europa}
comparacion.ES_UE.remun <- data %>% 
    filter(geo %in% c("ES", "EU27_2020"), item=="D1_SAL_HW", unit=="EUR", sector=="TOTAL") %>% 
    select(year, geo, values) %>% 
    mutate(geo = ifelse(geo == "EU27_2020", "Unión Europea", "España")) %>% 
    as_tsibble(index = year, key = geo) %>% 
    fill_gaps()

comparacion.ES_UE.remun %>% rename(Región = geo) %>% 
    autoplot() +
    labs(title = "Coste laboral por hora trabajada - ES vs IC", x = "Año", y = "EUR / Hora") +
    scale_color_manual(values = c("Unión Europea" = "green", "España" = "red"))
```

Finalmente, el modelo ARIMA aplicado a la remuneración muestra un ajuste más preciso que el de las horas trabajadas y proyecta un aumento moderado y constante en los próximos años, consolidando la tendencia positiva observada en el periodo reciente.
```{verbatim evolucion-remun-españa-arima, results = F}
remun.españa.arima <- remun.españa %>% 
    model(ARIMA(values))
```
```{verbatim descomposicion-remun-españa}
remun.españa.STL <- remun.españa %>% 
    model(STL(values,robust = TRUE)) %>% 
    components()

remun.españa.STL %>% 
    autoplot() +
    labs(x="Año")
```

```{verbatim evolucion-remun-españa-prediccion}
remun.españa.prediccion <- remun.españa.arima %>%
     forecast(h="5 years")

remun.españa.prediccion %>% 
    autoplot(remun.españa) +
    labs(title = "Coste laboral por hora trabajada en ES - Predicción futura", x = "Año", y = "EUR / Hora")
```

```{verbatim real-vs-arima-remun, fig.width=8}
# Generamos el data frame con los valores reales y ajustados del modelo
ajuste_horas <- remun.españa.arima %>% 
  augment()  # añade columnas .fitted y .resid

# Gráfico de comparación entre los valores reales y el ajuste del modelo ARIMA
ajuste_horas %>%
  ggplot(aes(x = year)) +
  geom_line(aes(y = values, colour = "Real")) +
  geom_line(aes(y = .fitted, colour = "Ajuste ARIMA"), linetype = "dashed") +
  labs(
    title = "Calidad ajuste del modelo ARIMA - Coste laboral hora trabajada ES",
    x = "Año", y = "EUR / Hora"
  ) +
  scale_colour_manual(values = c("Real" = "black", "Ajuste ARIMA" = "red")) +
  theme(legend.title = element_blank())
```

## Evaluación

<!-- desarrollo de esta fase -->

## Despliegue

<!-- desarrollo de esta fase -->

# Conclusiones y trabajo futuro


## Conclusiones

<!-- Revisión clara y concisa de los hallazgos más relevantes del estudio, vinculados directamente con los objetivos o hipótesis planteados. Reconocimiento honesto de los puntos débiles o restricciones (por ejemplo, tamaño de muestra reducido, falta de datos, sesgos.  Evitar aquí generalidades de ChatGPT --> 

## Trabajo futuro

<!-- Líneas de trabajo futuro, aspectos pendientes, posibles extensiones. --> 


## Anexo. Seguimiento temporal actividades del proyecto  {-} 


<!-- Lo primero que hay que hacer es compartir en modo lectura la hoja de cálculo Google Sheet que habremos descargado del Campus Virtual para registrar las sesiones de trabajo. A continuación se sustituirá, debajo, el enlace que figura en la lectura del archivo (read_sheet) por el enlace compartido que has creado. 

ES OBLIGATORIO TENER ACTUALIZADO ESTE APARTADO EN CADA ENTREGA DEL PROYECTO. 

CADA SESIÓN DE TRABAJO SE DEBE REGISTRAR EN LA GOOGLE SHEET EN EL MOMENTO DE REALIZARSE. EN PARTICULAR EN UNA ENTREGA  DEL PROYECTO NO PUEDEN APARECER SESIONES DE TRABAJOS NUEVAS CON FECHAS ANTERIORES A LA ENTREGA ANTERIOR DEL PROYECTO. 
-->

<!-- 
IMPORTANTE: La primera vez que ejecutes este chunk desde la consola de R se te pedirá gestionar una autorización para usar una cuenta Google. Es decir, en medio de la ejecución del chunk,  ve a la consola de R y ten en cuenta lo que se te pide. 
-->


```{r}
gs4_deauth() 
SeguimientoActividadesProyecto <- read_sheet('https://docs.google.com/spreadsheets/d/1W6VrcVWawxEk-b0zxrtVtOn-dtGl86BYEAWZ4qOYe0g/edit?usp=sharing') %>%
  as_tibble()

```

TOTAL HORAS TRABAJADAS EN EL PROYECTO : `r  round(sum(SeguimientoActividadesProyecto$MINUTES/60, na.rm=TRUE),digits=2)`


```{r, fig.width=9}
actividades <- c("Introducción","Aportaciones del trabajo","Compresión del negocio","Comprensión de los datos","Preparación de los datos","Modelado","Evaluación","Despliegue","Conclusiones y Trabajo Futuro","Otros")
p <- SeguimientoActividadesProyecto%>%
  group_by(ACTIVITY)%>%
   summarise(
     HORAS=round(sum(MINUTES)/60,digits = 1)
   )%>%
  mutate(ACTIVITY=factor(ACTIVITY,levels=actividades)) %>% 
  na.omit() %>% 
  ggplot(aes(ACTIVITY,HORAS)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label=HORAS),size=3,colour = "blue",nudge_y = 0.2)+ 
  theme(axis.text.x = element_text(angle = 45,hjust=1))+
  labs(x="",y="HORAS TRABAJADAS",title = "TOTAL HORAS TRABAJADAS EN EL PROYECTO POR ACTIVIDAD")

ggplotly(p)

```

```{r,fig.width=9,cache=FALSE}
p <- SeguimientoActividadesProyecto%>%
  mutate(week=yearweek(as.Date(START))) %>% 
  group_by(week)%>%
   summarise(
     HORAS=round(sum(MINUTES)/60,digits = 1)
   )%>%
  ggplot(aes(week,HORAS)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label=HORAS),size=3,colour = "blue",nudge_y = 0.2)+ 
  theme(axis.text.x = element_text(angle = 45,hjust=1))+
  labs(x="",y="HORAS TRABAJADAS",title = "TOTAL HORAS TRABAJADAS POR SEMANA")

ggplotly(p)
  
 
```

**DESGLOSE DETALLADO DE LAS SESIONES DE TRABAJO**
```{r}
SeguimientoActividadesProyecto%>% 
  datatable(
  options = list(
    scrollX = TRUE,   # Scroll horizontal
    scrollY = "400px", # Scroll vertical
    paging = FALSE     # Desactiva paginación si quieres solo scroll
  )
)

```
